- title: Розділ 7 - Об'єктно-орієнтоване програмування
  content_markdown: >
    Вираження ідей за допомогою функцій є перевіреним способом представлення поведінки та даних (мова C робить це протягом десятиліть!). Історично склалося так, що комп'ютерні науки знайшли інші корисні виразні агрегації та абстракції для даних. Можливо, ви знайомі з об'єктно-орієнтованим програмуванням (ООП) як одним з таких способів. У цьому розділі ми розглянемо мову програмування Rust за межами функцій.
- title: Що таке ООП?
  content_markdown: >
    Об'єктно-орієнтоване програмування приблизно відноситься до мов програмування, які мають ряд знакових особливостей:

    * Інкапсуляція - об'єднання даних та функцій у концептуальну одиницю єдиного типу, яка називається *об'єкт*.

    * Абстракція  - приховування даних і членів функцій для приховування деталей реалізації об'єкта.

    * Поліморфізм - здатність взаємодіяти з об'єктами різних типів через один інтерфейс.

    * Спадкування - можливість успадковувати дані та поведінку від інших об'єктів.
- title: Rust - це не ООП
  content_markdown: >
    У Rust відсутнє успадкування даних та поведінки у будь-який значущий спосіб.


    * Структури не можуть успадковувати значення полів від батьківської структури.

    * Структури не можуть успадковувати функції від батьківської структури.


    Тим не менш, Rust реалізує багато можливостей мови програмування, так що ви можете не турбуватися про цей недолік.
- title: Інкапсуляція з методами
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20creature.get_sound())%3B%0A%7D%0A
  content_markdown: >
    Rust підтримує концепцію *об'єкта*, який є структурою, пов'язаною з деякими функціями (також відомими як *методи*).


    Першим параметром будь-якого методу має бути посилання на екземпляр, пов'язаний з викликом методу (наприклад, `instanceOfObj.foo()`). Rust використовує:

    * `&self` - незмінне посилання на екземпляр.

    * `&mut self` - змінюване посилання на екземпляр.


    Методи визначаються у блоці реалізації з ключовим словом `impl`:

    ```rust

    impl MyStruct {
        ...
        fn foo(&self) { ...
            ...
        }
    }

    ```
- title: Абстракція з вибірковою експозицією
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріс%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20creature.get_sound())%3B%0A%7D%0A
  content_markdown: >
    Rust може приховувати внутрішню роботу об'єктів.


    За замовчуванням поля і методи доступні тільки для модуля, до якого вони належать.


    Ключове слово `pub` розкриває поля та методи структур за межами модуля.
- title: Поліморфізм з ознаками
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріс%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A
  content_markdown: >
    Rust підтримує поліморфізм за допомогою ознак. Риси дозволяють нам пов'язати набір методів з типом структури.


    Спочатку ми визначаємо сигнатури методів ознаки всередині:


    ```

    trait MyTrait {
        fn foo(&self);
        ...
    }

    ```


    Коли структура реалізує ознаку, вона встановлює контракт, який дозволяє нам опосередковано взаємодіяти зі структурою через тип ознаки (наприклад, `&dyn MyTrait`) без необхідності знати реальний тип.


    Реалізовані методи ознак структури визначаються у блоці реалізації:


    ```rust

    impl MyTrait for MyStruct {
        fn foo(&self) {
            ...
        }
        ...
    }

    ```
- title: Реалізовані методи для ознак
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%20%20%20%20%0A%20%20%20%20fn%20make_alot_of_noise(%26self)%7B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріс%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_alot_of_noise()%3B%0A%7D%0A
  content_markdown: >
    Ознаки можуть мати реалізовані методи.


    Функції не мають прямого доступу до внутрішніх полів структури, але це може бути корисно для спільного використання поведінки між багатьма реалізаторами ознак.

- title: Успадкування ознак
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Atrait%20LoudNoiseMaker%3A%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_alot_of_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%20%20%20%20self.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20LoudNoiseMaker%20for%20SeaCreature%20%7B%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріс%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20creature.make_alot_of_noise()%3B%0A%7D%0A
  content_markdown: |
    Ознаки можуть успадковувати методи від інших ознак.
- title: Динамічна та статична диспетчеризація
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20static_make_noise(creature%3A%20%26SeaCreature)%20%7B%0A%20%20%20%20%2F%2F%20ми%20знаємо%20реальний%20тип%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20dynamic_make_noise(noise_maker%3A%20%26dyn%20NoiseMaker)%20%7B%0A%20%20%20%20%2F%2F%20ми%20не%20знаємо%20реальний%20тип%0A%20%20%20%20noise_maker.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріс%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20static_make_noise(%26creature)%3B%0A%20%20%20%20dynamic_make_noise(%26creature)%3B%0A%7D%0A
  content_markdown: >
    Методи виконуються двома способами:

    * статична диспетчеризація - коли тип екземпляра відомий, ми безпосередньо знаємо, яку функцію викликати.

    * динамічна диспетчеризація - коли тип екземпляру невідомий, ми повинні знайти спосіб виклику правильної функції.


    Типи ознак `&dyn MyTrait` дають нам можливість працювати з екземплярами об'єктів опосередковано, використовуючи динамічну диспетчеризацію.


    Якщо використовується динамічна диспетчеризація, Rust рекомендує вам поставити `dyn` перед типом ознаки, щоб люди знали про це.


    Деталі пам'яті:

    * Динамічна диспетчеризація дещо повільніша через гонитву за вказівником у пошуках реального виклику функції.
- title: Об'єкти ознак
  content_markdown: >
    Коли ми передаємо екземпляр об'єкта параметру типу `&dyn MyTrait`, ми передаємо те, що називається *об'єкт ознаки*.


    Об'єкт ознаки - це те, що дозволяє нам опосередковано викликати правильні методи екземпляра. Об'єкт ознаки - це структура, яка містить вказівник на на наш екземпляр зі списком вказівників функцій на методи нашого екземпляра.


    Деталі пам'яті:

    * Цей список функцій відомий у C++ як *vtable*.
- title: Обробка нерозмірних даних
  content_markdown: >
    Ознаки створюють цікавий виклик, коли ми хочемо зберігати їх в іншій структурі. Ознаки змінюють оригінальну структуру, а отже, змінюють і її розмір. Нерозмірні значення, що зберігаються у структурах, у Rust обробляються двома способами:


    * `загальні` - Використання параметризованих типів ефективно створює структури/функції відомих типів, а отже і відомих розмірів.

    * `непряме звертання` - Розміщення екземплярів у купі дає нам рівень непрямості, який дозволяє нам не турбуватися про розмір фактичного типу і просто зберігати вказівник на нього. Існують і інші способи!
- title: Загальні функції
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20generic_make_noise%3CT%3E(creature%3A%20%26T)%0Awhere%0A%20%20%20%20T%3A%20NoiseMaker%2C%0A%7B%0A%20%20%20%20%2F%2F%20ми%20знаємо%20реальний%20тип%20на%20етапі%20компіляції%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріс%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20generic_make_noise(%26creature)%3B%0A%7D%0A
  content_markdown: >
    Загальні типи у Rust працюють пліч-о-пліч з ознаками. Коли ми описуємо параметризований тип `T`, ми можемо обмежити, які типи можуть бути використані як аргументи, перелічивши необхідні риси, які повинен реалізовувати аргумент.


    У даному прикладі тип `T` повинен реалізовувати властивість `Foo`:

    ```rust

    fn my_function<T>(foo: T)

    where
        T:Foo
    {
        ...
    }

    ```


    Використовуючи загальні типи, ми створюємо статичні типізовані функції під час компіляції, які матимуть відомі типи та розміри, що дозволяє нам виконувати статичну диспетчеризацію та зберігати їх у вигляді значень.
- title: Скорочення загальних функцій
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20generic_make_noise(creature%3A%20%26impl%20NoiseMaker)%0A%7B%0A%20%20%20%20%2F%2F%20ми%20знаємо%20реальний%20тип%20на%20етапі%20компіляції%0A%20%20%20%20creature.make_noise()%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20creature%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріс%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20generic_make_noise(%26creature)%3B%0A%7D%0A
  content_markdown: |
    Rust має скорочення для вираження загальних типів, обмежених ознакою:

    ```rust
    fn my_function(foo: impl Foo) {
        ...
    }
    ```

    Це еквівалентно написанню:

    ```rust
    fn my_function<T>(foo: T)
    where
        T:Foo
    {
        ...
    }
    ```
- title: Box
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20noise%3A%20String%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20pub%20fn%20get_sound(%26self)%20-%3E%20%26str%20%7B%0A%20%20%20%20%20%20%20%20%26self.noise%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20NoiseMaker%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%3B%0A%7D%0A%0Aimpl%20NoiseMaker%20for%20SeaCreature%20%7B%0A%20%20%20%20fn%20make_noise(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20%26self.get_sound())%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20Ocean%20%7B%0A%20%20%20%20animals%3A%20Vec%3CBox%3Cdyn%20NoiseMaker%3E%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22blub%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Sarah%22)%2C%0A%20%20%20%20%20%20%20%20noise%3A%20String%3A%3Afrom(%22swish%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20ocean%20%3D%20Ocean%20%7B%0A%20%20%20%20%20%20%20%20animals%3A%20vec!%5BBox%3A%3Anew(ferris)%2C%20Box%3A%3Anew(sarah)%5D%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20for%20a%20in%20ocean.animals.iter()%20%7B%0A%20%20%20%20%20%20%20%20a.make_noise()%3B%0A%20%20%20%20%7D%0A%7D%0A
  content_markdown: >
    `Box` - це структура даних, яка дозволяє нам переміщати дані зі стеку в купу.


    `Box` - це структура, відома як *розумний вказівник*, яка містить вказівник на наші дані у купі.


    Оскільки `Box` - це структура з відомим розміром (оскільки вона містить лише вказівник), її часто використовують як спосіб зберігання посилання на щось у структурі, що має знати розмір своїх полів.


   `Box` настільки розповсюджений, що його можна використовувати звідусіль:


    ```rust

    Box::new(Foo { ... })

    ```
- title: Переглянуті загальні структури
  content_markdown: >
    Загальні структури також можуть мати параметризовані типи, обмежені ознаками.


    ```rust

    struct MyStruct<T>

    where
        T: MyTrait
    {
        foo: T
        ...
    }

    ```


    Загальні структури мають параметризований тип у своїх блоках реалізації:


    ```rust

    impl<T> MyStruct<T> {
        ...
    }

    ```
- title: Розділ 7 - Висновки
  content_markdown: >
    Тепер у нас під рукою є більше можливостей мови для чіткого представлення наших ідей! Абстракції Rust можуть бути простими, але вони досить потужні, щоб зробити роботу з кодом приємною. У цій главі ми побіжно познайомилися з розумними вказівниками за допомогою `Box`. У наступній главі ми дізнаємося про те, як розумні вказівники можуть допомогти нам в інших спеціалізованих ситуаціях з пам'яттю.


    Ресурси:

    * [Відео - Об'єктно-орієнтоване програмування за 7
    хвилин] (https://www.youtube.com/watch?v=pTB0EiLXUC8)

    * [Стаття - "Чим швидше ви розучите ООП, тим краще для вас і вашого
    програмного забезпечення"] (https://dpc.pw/the-faster-you-unlearn-oop-the-better-for-you-and-your-software)
