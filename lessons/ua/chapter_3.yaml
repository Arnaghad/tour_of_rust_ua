- title: Розділ 3 - Основні типи структур даних
  content_markdown: >
    Настав час вийти за рамки базових типів! У цій главі ми розглянемо найпримітивніші структури даних у Rust, приділяючи особливу увагу їхньому представленню в пам'яті. Я думаю, що вам сподобається, як мало Rust приховує від вас того, як все працює.

- title: Структури
  content_markdown: >
    `struct` (структура) - це колекція полів.


    *field* (поле) - це просто значення даних, пов'язане зі структурою даних. Його значення може мати примітивний тип або структуру даних.


    Його визначення схоже на план для компілятора, як розташувати поля в пам'яті поруч одне з одним.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20%2F%2F%20Рядок%20-%20це%20структура%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D

- title: Виклик методів
  content_markdown: >
    На відміну від функцій, методи - це функції, пов'язані з певним типом даних.


    **статичні методи** - методи, що належать самому типу, викликаються за допомогою оператора `::`.


    **методи екземпляру** - методи, що належать екземпляру типу, викликаються за допомогою оператора `.`.


    Ми поговоримо про створення власних методів у наступних розділах.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Використання%20статичного%20методу%20для%20створення%20екземпляру%20типу%20String%0A%20%20%20%20let%20s%20%3D%20String%3A%3Afrom(%22Привіт,%20світ!%22)%3B%0A%20%20%20%20%2F%2F%20Використання%20методу%20в%20екземплярі%0A%20%20%20%20println!(%22%7B%7D%20довжиною%20%7B%7D%20символів%22%2C%20s%2C%20s.len())%3B%0A%7D%0A

- title: Пам'ять
  content_markdown: >
    Програми на Rust мають 3 області пам'яті, де зберігаються дані:

    * **пам'ять даних** (data memory) - для даних, які мають фіксований розмір і є **статичними** (тобто завжди доступними протягом усього життя програми).  Розглянемо текст у вашій програмі (наприклад, «Привіт, Світ!»): Байти цього тексту зчитуються лише з одного місця і тому можуть зберігатися у цій області. Компілятори роблять багато оптимізацій для такого типу даних, і вони зазвичай вважаються дуже швидкими у використанні, оскільки місцезнаходження відоме і фіксоване.

    * **стекова пам'ять** (stack memory) - для даних, які оголошуються як змінні у функції. Розташування цієї пам'яті ніколи не змінюється протягом виклику функції; завдяки цьому компілятори можуть оптимізувати код так, що доступ до стекових даних є дуже швидким.

    * **купа пам'яті** (heap memory) - для даних, які створюються під час роботи програми. Дані в цій області можна додавати, переміщувати, видаляти, змінювати розмір тощо. Через свою динамічну природу вона зазвичай вважається повільнішою у використанні, але дозволяє більш творчо використовувати пам'ять. Коли дані додаються до цієї області, ми називаємо це **розміщенням** (allocation). Коли дані видаляються з цієї ділянки, ми називаємо це **вивільненням** (deallocation).

- title: Створення даних у пам'яті
  content_markdown: >
    Коли ми **створюємо екземпляр** (instantiate) **структури** (struct) в нашому коді, наша програма створює пов'язані з нею дані полів поруч у пам'яті.


    Ми створюємо екземпляр, вказуючи всі значення полів в межах


    `StructName { ... }`. 


    Доступ до полів структури здійснюється з допомогою крапкового оператора `.`.


    Деталі пам’яті нашого прикладу:

    * Текст всередині лапок є даними тільки для читання (наприклад, «Ферріс»), тому він розміщується в *області пам'яті даних*.

    * Виклик функції `String::from` створює структуру `String`, яка розміщується поряд з полями SeaCreature у *стеку*. Рядок представляє текст, який можна змінювати і робить це наступним чином:
      1. Створення пам'яті у *купі* для тексту, де його можна змінювати
      2. Зберігання посилання на цю ділянку пам'яті у *купі* та збереження його у структурі `String` (докладніше про це у наступних уроках)

    * Нарешті, наші два друга *Ферріс* та *Сара* мають структури даних, які завжди будуть мати фіксоване розташування у нашій програмі, тому вони розміщені у *стеку*.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20SeaCreature%20%7B%0A%20%20%20%20animal_type%3A%20String%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Дані%20SeaCreature%20зберігаються%20у%20стеку%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Структура%20String%20також%20знаходиться%20на%20стеку%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20але%20місmить%20посилання%20на%20дані%20на%20купі%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22краб%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріс%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22клішня%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20animal_type%3A%20String%3A%3Afrom(%22восьминіг%22)%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Сара%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%208%2C%0A%20%20%20%20%20%20%20%20legs%3A%200%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22жодного%22)%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20це%20%7B%7D.%20Вони%20мають%20%7B%7D%20руки%2C%20%7B%7D%20ноги%2C%20і%20%7B%7D%20як%20засіб%20самозахисту%22%2C%0A%20%20%20%20%20%20%20%20ferris.name%2C%20ferris.animal_type%2C%20ferris.arms%2C%20ferris.legs%2C%20ferris.weapon%0A%20%20%20%20)%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20це%20%7B%7D.%20Вони%20мають%20%7B%7D%20руки%2C%20і%20%7B%7D%20ніг.%20Вони%20не%20мають%20засобу%20самозахисту..%22%2C%0A%20%20%20%20%20%20%20%20sarah.name%2C%20sarah.animal_type%2C%20sarah.arms%2C%20sarah.legs%0A%20%20%20%20)%3B%0A%7D%0A

- title: Структури, подібні до кортежів
  content_markdown: |
    Для стислості ви можете створювати структури, які використовуються як кортеж.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Location(i32%2C%20i32)%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Це%20все%20ще%20структура%20на%20стеку%0A%20%20%20%20let%20loc%20%3D%20Location(42%2C%2032)%3B%0A%20%20%20%20println!(%22%7B%7D%2C%20%7B%7D%22%2C%20loc.0%2C%20loc.1)%3B%0A%7D%0A

- title: Одиничні структури (Unit-like Structs)
  content_markdown: >
    Структури не повинні мати полів взагалі.


    Як згадувалося у Розділі 1, *одиниця* (unit) - це інше слово для позначення порожнього кортежу `()`. Ось чому цей тип структур називається *Одиничною*.


    Цей тип структури використовується рідко.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Marker%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20_m%20%3D%20Marker%3B%0A%7D%0A

- title: Переліки
  content_markdown: >
    Переліки дозволяють створити новий тип, який може мати значення декількох позначених елементів за допомогою ключового слова `enum`.


    `match` допомагає забезпечити вичерпну обробку всіх можливих значень enum, що робить його потужним інструментом у забезпеченні якості коду.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20цей%20рядок%20запобігає%20попередженням%20компілятора%0A%0Aenum%20Species%20%7B%0A%20%20%20%20Crab%2C%0A%20%20%20%20Octopus%2C%0A%20%20%20%20Fish%2C%0A%20%20%20%20Clam%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріч%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20String%3A%3Afrom(%22клішня%22)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20println!(%22%7B%7D%20це%20краб%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AOctopus%20%3D%3E%20println!(%22%7B%7D%20це%20восьминіг%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AFish%20%3D%3E%20println!(%22%7B%7D%20це%20риба%22%2Cferris.name)%2C%0A%20%20%20%20%20%20%20%20Species%3A%3AClam%20%3D%3E%20println!(%22%7B%7D%20це%20молюск%22%2Cferris.name)%2C%0A%20%20%20%20%7D%0A%7D%0A

- title: Переліки з даними
  content_markdown: >
    Елементи `enum` також можуть мати один або декілька типів даних, що дозволяє їм поводитися як *union* з C.


    Коли `enum` зіставляється з шаблоном за допомогою `match`, ви можете прив'язати ім'я змінної до кожного значення даних.


    Деталі про пам'ять `enum`:

    * Значення даних переліку матиме розмір пам'яті, що дорівнює його найбільшому елементу. Це дозволяє всім потенційним значенням поміститися в одній ділянці пам'яті.

    * Окрім типів даних елементів (якщо вони є), кожен елемент також має числове значення, яке вказує на його тег (мітку).


    Інші деталі:

    * У Rust `enum` - це те, що також відоме як *мічене об'єднання* (tagged union).

    * Комбінування типів для створення нового типу - це те, що люди мають на увазі, коли кажуть, що Rust має *алгебраїчні типи*.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%23!%5Ballow(dead_code)%5D%20%2F%2F%20цей%20рядок%20запобігає%20попередженням%20компілятора%0A%0Aenum%20Species%20%7B%20Crab%2C%20Octopus%2C%20Fish%2C%20Clam%20%7D%0Aenum%20PoisonType%20%7B%20Acidic%2C%20Painful%2C%20Lethal%20%7D%0Aenum%20Size%20%7B%20Big%2C%20Small%20%7D%0Aenum%20Weapon%20%7B%0A%20%20%20%20Claw(i32%2C%20Size)%2C%0A%20%20%20%20Poison(PoisonType)%2C%0A%20%20%20%20None%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20species%3A%20Species%2C%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20arms%3A%20i32%2C%0A%20%20%20%20legs%3A%20i32%2C%0A%20%20%20%20weapon%3A%20Weapon%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Дані%20SeaCreature%20зберігаються%20у%20стеку%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Структура%20string%20також%20знаходиться%20на%20стеку%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20але%20містить%20посилання%20на%20дані%20на%20купі%0A%20%20%20%20%20%20%20%20species%3A%20Species%3A%3ACrab%2C%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ферріс%22)%2C%0A%20%20%20%20%20%20%20%20arms%3A%202%2C%0A%20%20%20%20%20%20%20%20legs%3A%204%2C%0A%20%20%20%20%20%20%20%20weapon%3A%20Weapon%3A%3AClaw(2%2C%20Size%3A%3ASmall)%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20match%20ferris.species%20%7B%0A%20%20%20%20%20%20%20%20Species%3A%3ACrab%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20match%20ferris.weapon%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Weapon%3A%3AClaw(num_claws%2Csize)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20size_description%20%3D%20match%20size%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ABig%20%3D%3E%20%22великими%22%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Size%3A%3ASmall%20%3D%3E%20%22маленькими%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20println!(%22ферріс%20-%20це%20краб%20з%20%7B%7D%20%7B%7D%20клішнями%22%2C%20num_claws%2C%20size_description)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ферріс%20-%20це%20краб%20з%20якимось%20іншим%20засобом%20самооборони%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20println!(%22ферріс%20-%20це%20якась%20інша%20тварина%22)%2C%0A%20%20%20%20%7D%0A%7D

- title: Розділ 3 - Висновки
  content_markdown: >
    Як захоплююче! Тепер у нас є найпростіші інструменти для представлення форми наших ідей у коді. Сподіваємось, тепер ми можемо побачити, як фундаментальні операції Rust працюють у гармонії та лаконічності з його типами. Далі ми поговоримо про концепцію, яка дає нашим типам даних ще більшу гнучкість представлення: *загальні* (generics).
