- title: Розділ 8 - Розумні вказівники
  content_markdown: >
    У цьому розділі ми розсекретимо розумні вказівники. Розглянемо ці структури даних, які дозволяють нам взаємодіяти з найнижчим рівнем пам'яті.


    Ферріс каже: «Не відчувайте себе пригніченими цим розділом, якщо ви не відчуваєте, що можете написати свій власний низькорівневий код управління пам'яттю за одне коротке прочитання. Ця глава в основному призначена для того, щоб познайомити вас з деякими корисними інструментами і дати уявлення про те, як вони працюють!»
- title: Переглядаємо посилання
  content_markdown: >
    По суті, посилання - це просто число, яке є початковою позицією деяких байтів у пам'яті. Його єдине призначення - представляти концепцію того, де існують дані певного типу. Відмінність посилання від простого числа полягає у тому, що Rust перевіряє, щоб час життя посилання не перевищував час життя того, на що воно посилається (інакше ми б отримали помилку при його використанні!).
- title: Необробленні вказівники
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20memory_location%20%3D%20%26a%20as%20*const%20i32%20as%20usize%3B%0A%20%20%20%20println!(%22Дані%20знаходяться%20тут%3A%20%7B%7D%22%2C%20memory_location)%3B%0A%7D%0A
  content_markdown: >
    Посилання можна перетворити на більш примітивний тип, який називається *необроблений вказівник*. Подібно до числа, його можна копіювати та переміщувати з невеликими обмеженнями. Rust не надає жодних гарантій щодо дійсності комірки пам'яті, на яку він вказує.


    Існує два типи необроблених вказівників:


    * `*const T` - необроблений вказівник на дані типу T, який ніколи не повинен змінюватися.

    * `*mut T` - необроблений вказівник на дані типу T, який може змінюватися.


    Необроблені вказівники можуть бути перетворені в числа і з чисел (наприклад, `usize`).

    Необроблені вказівники можуть отримувати доступ до даних з *небезпечним* кодом (детальніше про це пізніше).


    Деталі про пам'ять:

    * Посилання у Rust дуже схоже на вказівник у C з точки зору використання, але з набагато більшими обмеженнями під час компіляції на те, як його можна зберігати і переміщати до інших функцій.

    * Необроблений вказівник у Rust подібний до вказівника у C тим, що він являє собою число, яке можна копіювати або передавати, і навіть перетворювати у числові типи, де його можна модифікувати як число для виконання математичних дій з вказівниками.

- title: Видалення посилань
  content_markdown: |
    Процес доступу/маніпуляції з даними, на які посилається *посилання* (тобто `&i32`), називається *видалення посилань*.


    Посилання використовуються для доступу/маніпулювання даними двома способами:

    * Доступ до даних, на які є посилання, під час присвоювання змінних.

    * Доступ до полів або методів даних, на які є посилання.


    Rust має декілька потужних операторів, які дозволяють нам це робити.
- title: Оператор *
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20i32%20%3D%2042%3B%0A%20%20%20%20let%20ref_ref_ref_a%3A%20%26%26%26i32%20%3D%20%26%26%26a%3B%0A%20%20%20%20let%20ref_a%3A%20%26i32%20%3D%20**ref_ref_ref_a%3B%0A%20%20%20%20let%20b%3A%20i32%20%3D%20*ref_a%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20b)%0A%7D
  content_markdown: >
    Оператор `*` є явним способом видалення посилання.

    ```rust

    let a: i32 = 42;

    let ref_ref_ref_a: &&&i32 = &&&a;

    let ref_a: &i32 = **ref_ref_ref_a;

    let b: i32 = *ref_a;

    ```


    Деталі про пам'ять:

    - Оскільки i32 є примітивним типом, який реалізує властивість `Copy`, байти змінної `a` у стеку копіюються у байти змінної `b`.

- title: Оператор .
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20value%3A%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20f%20%3D%20Foo%20%7B%20value%3A%2042%20%7D%3B%0A%20%20%20%20let%20ref_ref_ref_f%20%3D%20%26%26%26f%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20ref_ref_ref_f.value)%3B%0A%7D
  content_markdown: >
    Оператор `.` використовується для доступу до полів та методів посилання. Він працює трохи тонше.


    ```rust

    let f = Foo { value: 42 };

    let ref_ref_ref_f = &&&f;

    println!("{}", ref_ref_ref_f.value);

    ```

    А чому не треба було додавати `***` перед `ref_ref_ref_f`? Це тому, що оператор `.` автоматично видаляє послідовність посилань. Останній рядок автоматично перетворюється компілятором у наступний.


    ```rust

    println!("{}", (***ref_ref_ref_f).value);

    ```
- title: Розумні вказівники
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aops%3A%3ADeref%3B%0Astruct%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20value%3A%20T%2C%0A%7D%0Aimpl%3CT%3E%20Deref%20for%20TattleTell%3CT%3E%20%7B%0A%20%20%20%20type%20Target%20%3D%20T%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26T%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20було%20використано!%22%2C%20std%3A%3Aany%3A%3Atype_name%3A%3A%3CT%3E())%3B%0A%20%20%20%20%20%20%20%20%26self.value%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20TattleTell%20%7B%0A%20%20%20%20%20%20%20%20value%3A%20%22секретне%20повідомлення%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20%2F%2F%20Видалення%20посилань%20відбувається%20тут%20негайно%0A%20%20%20%20%2F%2F%20після%20автоматичного%20посилання%20foo%0A%20%20%20%20%2F%2F%20для%20функції%20%60len%60%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.len())%3B%0A%7D%0A
  content_markdown: >
    На додаток до можливості створювати посилання на існуючі типізовані дані за допомогою оператора `&`, Rust надає нам можливість створювати *посилання-подібні* структури, які називаються **розумні вказівники**.


    Ми можемо думати про посилання на високому рівні як про тип, який дає нам доступ до іншого типу.  Розумні покажчики відрізняються за своєю поведінкою від звичайних посилань тим, що вони працюють на основі внутрішньої логіки, яку пише програміст. Ви - програміст - є *розумною* частиною.


    Зазвичай розумні вказівники реалізують ознаки `Deref`, `DerefMut` та `Drop`, які визначають логіку дій, що мають відбуватися, коли на структуру розіменовуються операторами `*` та `.`.
- title: Розумний небезпечний код
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%5Bu8%3B%204%5D%20%3D%20%5B86%2C%2014%2C%2073%2C%2064%5D%3B%0A%20%20%20%20%2F%2F%20Це%20необроблений%20вказівник.%20Отримання%20адреси%20пам'яті%0A%20%20%20%20%2F%2F%20чогось%20як%20числа%20є%20повністю%20безпечним%0A%20%20%20%20let%20pointer_a%20%3D%20%26a%20as%20*const%20u8%20as%20usize%3B%0A%20%20%20%20println!(%22Розташування%20даних%20у%20пам'яті%3A%20%7B%7D%22%2C%20pointer_a)%3B%0A%20%20%20%20%2F%2F%20Перетворення%20нашого%20числа%20на%20необроблений%20вказівник%20на%20f32%0A%20%20%20%20%2F%2F%20також%20є%20безпечним%20діянням.%0A%20%20%20%20let%20pointer_b%20%3D%20pointer_a%20as%20*const%20f32%3B%0A%20%20%20%20let%20b%20%3D%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Це%20небезпечний%20код%2C%20оскільки%20ми%20говоримо%20компілятору%0A%20%20%20%20%20%20%20%20%2F%2F%20вважати%2C%20що%20наш%20вказівник%20є%20коректним%20f32%2C%20і%0A%20%20%20%20%20%20%20%20%2F%2F%20видаляємо%20посилання%20на%20його%20значення%20у%20змінну%20b.%0A%20%20%20%20%20%20%20%20%2F%2F%20Rust%20не%20може%20перевірити%2C%20що%20ця%20передумова%20правильна.%0A%20%20%20%20%20%20%20%20*pointer_b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22Клянуся%2C%20це%20пиріг!%20%7B%7D%22%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Розумні вказівники досить часто використовують *небезпечний* код. Як згадувалося раніше, вони є поширеним інструментом для взаємодії з найнижчими рівнями пам'яті у Rust.


    Що таке небезпечний код? Небезпечний код поводиться точно так само, як і нормальний Rust, за винятком кількох можливостей, щодо яких компілятор Rust не може надати гарантій.


    Основною можливістю небезпечного коду є *видалення посилань на необроблений вказівник*. Це означає, що ви берете *необроблений вказівник* на позицію в пам'яті і оголошуєте «тут існує структура даних!» і перетворюєте її на представлення даних, які ви можете використовувати (наприклад, `*const u8` в `u8`). Rust не має можливості відстежувати значення кожного байту, який записується до пам'яті. Оскільки Rust не може гарантувати, що існує за довільним номером, який використовується як *необроблений вказівник*, він поміщає видалення посилання у `unsafe { ... }` блок.


    Розумні вказівники широко застосовуються для видалення посилань сирих вказівників, але вони добре зарекомендували себе у тому, що вони роблять.
- title: Знайомі друзі
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Aalloc%3A%3A%7Balloc%2C%20Layout%7D%3B%0Ause%20std%3A%3Aops%3A%3ADeref%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20secret_recipe%3A%20usize%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20new()%20-%3E%20Self%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20запитуємо%204%20байти%0A%20%20%20%20%20%20%20%20let%20layout%20%3D%20Layout%3A%3Afrom_size_align(4%2C%201).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20виділяємо%20пам'ять%20і%20зберігаємо%20її%20адресу%20як%20число%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20ptr%20%3D%20alloc(layout)%20as%20*mut%20u8%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20використовуємо%20арифметику%20вказівників%20і%20записуємо%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20кілька%20значень%20u8%20у%20пам'ять%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.write(86)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(1).write(14)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(2).write(73)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20ptr.add(3).write(64)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20Pie%20%7B%20secret_recipe%3A%20ptr%20as%20usize%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0Aimpl%20Deref%20for%20Pie%20%7B%0A%20%20%20%20type%20Target%20%3D%20f32%3B%0A%20%20%20%20fn%20deref(%26self)%20-%3E%20%26f32%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20інтерпретуємо%20secret_recipe%20як%20необроблений%20вказівник%20на%20f32%0A%20%20%20%20%20%20%20%20let%20pointer%20%3D%20self.secret_recipe%20as%20*const%20f32%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20видаляємо%20посилання%20та%20повертаємо%20значення%20%26f32%0A%20%20%20%20%20%20%20%20unsafe%20%7B%20%26*pointer%20%7D%0A%20%20%20%20%7D%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20p%20%3D%20Pie%3A%3Anew()%3B%0A%20%20%20%20%2F%2F%20%22готуємо%20пиріг%22%20шляхом%20видалення%20посилання%20з%20%0A%20%20%20%20%2F%2F%20розумного%20вказівника%20структури%20Pie%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20*p)%3B%0A%7D%0A
  content_markdown: >
    Розглянемо деякі розумні вказівники, які ми вже бачили, такі як `Vec<T>` та `String`.

    `Vec<T>` - це розумний вказівник, який просто володіє деякою областю пам'яті у байтах. Компілятор Rust не має уявлення про те, що знаходиться у цих байтах. Розумний вказівник інтерпретує, що означає захоплення елементів з області пам'яті, якою він керує, відстежує, де починаються і де закінчуються структури даних у цих байтах, а потім, нарешті, розіменовує сирий вказівник на структури даних у гарний чистий ергономічний інтерфейс, яким ми можемо користуватися (наприклад, `my_vec[3]`).


    Аналогічно, `String` відстежує область пам'яті з байтів і програмно обмежує вміст, записаний до неї, щоб він завжди був коректним `utf-8` і допомагає розіменовувати цю область пам'яті на тип `&str`.


    Обидві ці структури даних використовують небезпечне розіменування сирих вказівників для виконання своєї роботи.


    Деталі про пам'ять:

    * Rust має еквівалент `malloc` у C, що використовує [alloc](https://doc.rust-lang.org/std/alloc/fn.alloc.html) та [Layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html ) для отримання доступу до ваших власних областей пам'яті для керування.
- title: Виділена пам'ять в купі
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22смакує%20краще%20в%20купі!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%7D%0A
  content_markdown: >
    `Box` - це розумний вказівник, який дозволяє нам переміщувати дані зі стеку до купи.


    Видалення посилань на нього дозволяє нам ергономічно використовувати дані, виділені в купі, так, ніби вони є оригінальним типом.
- title: Обробка помилок функції main
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Afmt%3A%3ADisplay%3B%0Ause%20std%3A%3Aerror%3A%3AError%3B%0A%0Astruct%20Pie%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20NotFreshError%3B%0A%0Aimpl%20Display%20for%20NotFreshError%20%7B%0A%20%20%20%20fn%20fmt(%26self%2C%20f%3A%20%26mut%20std%3A%3Afmt%3A%3AFormatter%3C%27_%3E)%20-%3E%20std%3A%3Afmt%3A%3AResult%20%7B%0A%20%20%20%20%20%20%20%20write!(f%2C%20%22Цей%20пиріг%20несвіжий!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Aimpl%20Error%20for%20NotFreshError%20%7B%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20Err(Box%3A%3Anew(NotFreshError))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20Box%3Cdyn%20Error%3E%3E%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Box%3A%3Anew(Pie)%3B%0A%20%20%20%20heap_pie.eat()%3F%3B%0A%20%20%20%20Ok(())%0A%7D%0A
  content_markdown: >
    Код Rust може мати безліч представлень помилок, але стандартна бібліотека має універсальну ознаку `std::error::Error` для опису помилок.


    Використовуючи розумний вказівник `Box`, ми можемо використовувати тип `Box<dyn std::error::Error>` як загальний тип для повернення помилок, тому що він дозволяє нам поширювати помилку вгору по купі і взаємодіяти з нею на високому рівні без необхідності знати конкретний тип.


    На початку Туру по Rust ми дізналися, що `main` може повертати помилку. Тепер ми можемо повертати тип, здатний описати майже будь-яку помилку, яка може виникнути у нашій програмі, якщо структура даних помилки реалізує загальну ознаку Rust `Error`.


    ```rust

    fn main() -> Result<(), Box<dyn std::error:Error>>

    ```
- title: Посилання на підрахунок
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22смакує%20краще%20в%20купі!%22)%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20heap_pie%20%3D%20Rc%3A%3Anew(Pie)%3B%0A%20%20%20%20let%20heap_pie2%20%3D%20heap_pie.clone()%3B%0A%20%20%20%20let%20heap_pie3%20%3D%20heap_pie2.clone()%3B%0A%0A%20%20%20%20heap_pie3.eat()%3B%0A%20%20%20%20heap_pie2.eat()%3B%0A%20%20%20%20heap_pie.eat()%3B%0A%0A%20%20%20%20%2F%2F%20всі%20розумні%20вказівники%20з%20лічильником%20посилань%20тепер%20звільнені%0A%20%20%20%20%2F%2F%20дані%20Pie%20в%20кучі%20остаточно%20видаляються%0A%7D%0A
  content_markdown: >
    `Rc` - це розумний вказівник, який переміщує дані зі стеку до купи. Це дозволяє нам клонувати інші розумні вказівники `Rc`, які мають можливість незмінно запозичувати дані, що були поміщені у купу.


    Тільки коли скидається останній розумний вказівник, дані на купі стають нерозподіленими.
- title: Спільний доступ
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26mut%20self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22смакує%20краще%20в%20купі!%22)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20RefCell%20перевіряє%20безпечність%20пам'яті%20під%20час%20виконання%0A%20%20%20%20%2F%2F%20зауважте%3A%20pie_cell%20не%20є%20mut!%0A%20%20%20%20let%20pie_cell%20%3D%20RefCell%3A%3Anew(Pie%7Bslices%3A8%7D)%3B%0A%20%20%20%20%0A%20%20%20%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20але%20ми%20можемо%20позичати%20змінні%20посилання!%0A%20%20%20%20%20%20%20%20let%20mut%20mut_ref_pie%20%3D%20pie_cell.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20mut_ref_pie.eat()%3B%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%2F%2F%20mut_ref_pie%20звільняється%20на%20кінці%20області%20видимості%0A%20%20%20%20%7D%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20тепер%20ми%20можемо%20отримати%20незмінне%20посилання%2C%20оскільки%20змінне%20посилання%20було%20звільнене%0A%20%20%20%20%20let%20ref_pie%20%3D%20pie_cell.borrow()%3B%0A%20%20%20%20%20println!(%22%7B%7D%20шматочків%20залишилось%22%2C%20ref_pie.slices)%3B%0A%7D%0A
  content_markdown: >
    `RefCell` - це контейнерна структура даних, яку зазвичай утримують розумні вказівники, що приймає дані і дозволяє нам запозичувати змінні та незмінні посилання на те, що знаходиться всередині. Вона запобігає зловживанню запозиченнями, застосовуючи правила безпеки пам'яті Rust під час виконання, коли ви запитуєте запозичення даних всередині:


    **Тільки одне змінюване посилання АБО декілька незмінних посилань, але не обидва разом!**.


    Якщо ви порушите ці правила, `RefCell` здійме паніку.
- title: Спільне доступ до даних у різних потоках
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Async%3A%3AMutex%3B%0A%0Astruct%20Pie%3B%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22зараз%20тільки%20я%20їм%20пиріг!%22)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mutex_pie%20%3D%20Mutex%3A%3Anew(Pie)%3B%0A%20%20%20%20%2F%2F%20позичимо%20заблоковане%20незмінне%20посилання%20на%20пиріг%0A%20%20%20%20%2F%2F%20нам%20потрібно%20розгорнути%20результат%20lock%0A%20%20%20%20%2F%2F%20оскільки%20блокування%20може%20зазнати%20невдачі%0A%20%20%20%20let%20ref_pie%20%3D%20mutex_pie.lock().unwrap()%3B%0A%20%20%20%20ref_pie.eat()%3B%0A%20%20%20%20%2F%2F%20заблоковане%20посилання%20звільняється%20тут%2C%20і%20значення%2C%20захищене%20м'ютексом%2C%20може%20використовувати%20хтось%20інший%0A%7D%0A
  content_markdown: >
    `Mutex` - це контейнерна структура даних, що зазвичай утримується розумними вказівниками, яка приймає дані і дозволяє нам запозичувати змінювані та незмінні посилання на дані всередині. Це запобігає зловживанню запозиченнями, коли операційна система обмежує доступ до даних лише одному потоку процесора, блокуючи інші потоки, доки початковий потік не закінчить роботу з заблокованим запозиченням.


    Багатопоточність виходить за рамки Туру по Rust, але `Mutex` є фундаментальною частиною організації роботи декількох потоків процесора, які отримують доступ до одних і тих же даних.


    Існує спеціальний розумний вказівник `Arc`, який ідентичний `Rc`, але використовує безпечне для потоку збільшення лічильників посилань. Його часто використовують, коли потрібно мати багато посилань на один і той самий `Mutex`.
- title: Поєднання розумних покажчиків
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acell%3A%3ARefCell%3B%0Ause%20std%3A%3Arc%3A%3ARc%3B%0A%0Astruct%20Pie%20%7B%0A%20%20%20%20slices%3A%20u8%2C%0A%7D%0A%0Aimpl%20Pie%20%7B%0A%20%20%20%20fn%20eat_slice(%26mut%20self%2C%20name%3A%20%26str)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20взяв%20шматочок!%22%2C%20name)%3B%0A%20%20%20%20%20%20%20%20self.slices%20-%3D%201%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20SeaCreature%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20pie%3A%20Rc%3CRefCell%3CPie%3E%3E%2C%0A%7D%0A%0Aimpl%20SeaCreature%20%7B%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20використовуємо%20розумний%20вказівник%20на%20пиріг%20для%20mutable%20borrow%0A%20%20%20%20%20%20%20%20let%20mut%20p%20%3D%20self.pie.borrow_mut()%3B%0A%20%20%20%20%20%20%20%20%2F%2F%20вкусити!%0A%20%20%20%20%20%20%20%20p.eat_slice(%26self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20pie%20%3D%20Rc%3A%3Anew(RefCell%3A%3Anew(Pie%20%7B%20slices%3A%208%20%7D))%3B%0A%20%20%20%20%2F%2F%20Ferris%20та%20Sarah%20отримують%20клони%20розумного%20вказівника%20на%20пиріг%0A%20%20%20%20let%20ferris%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Ferris%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20let%20sarah%20%3D%20SeaCreature%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20String%3A%3Afrom(%22Сара%22)%2C%0A%20%20%20%20%20%20%20%20pie%3A%20pie.clone()%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20ferris.eat()%3B%0A%20%20%20%20sarah.eat()%3B%0A%0A%20%20%20%20let%20p%20%3D%20pie.borrow()%3B%0A%20%20%20%20println!(%22%7B%7D%20шматочків%20залишилося%22%2C%20p.slices)%3B%0A%7D%0A
  content_markdown: >
    Розумні вказівники можуть здатися обмеженими, але вони можуть створювати дуже потужні комбінації.


    `Rc<Vec<Foo>>` - Дозволити клонування декількох розумних вказівників, які можуть запозичувати один і той самий вектор незмінних структур даних на купі.


    `Rc<RefCell<Foo>>` - Дозволити декільком розумним покажчикам запозичувати взаємно/незалежно одну й ту саму структуру `Foo`.


    `Arc<Mutex<Foo>>` - Дозволяє декільком смарт-вказівникам блокувати тимчасові змінювані/не змінювані запозичення виключно для потоку процесора.


    Деталі про пам'ять:

    * Ви помітите тему з багатьма з цих комбінацій. Використання незмінного типу даних (який може належати декільком розумним вказівникам) для модифікації внутрішніх даних. У Rust це називається патерном «внутрішня змінюваність». Це шаблон, який дозволяє нам змінювати правила використання пам'яті під час виконання з тим же рівнем безпеки, що і перевірки під час компіляції Rust.

- title: Розділ 8 - Висновок
  content_markdown: >
    Розумні вказівники - це ідіома програмування на Rust, яка дозволяє нам не створювати заново дуже поширені патерни використання пам'яті. З ними ви будете готові вирішувати найскладніші завдання! Тепер, коли ми ознайомилися з основами Rust, давайте трохи поговоримо про те, як ми створюємо більші проекти. У розділі 9 ми звільнимося від односторінкових рядків коду.
