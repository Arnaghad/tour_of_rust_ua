- title: Розділ 2 - Основний потік управління
  content_markdown: >
    У цьому розділі ми поговоримо про основні методи управління потоками у Rust. Якщо ви знайомі з мовами, заснованими на C, ви почуватиметеся як вдома і, можливо, зможете насолодитися одним-двома сюрпризами.

- title: if/else
  content_markdown: >
    Розгалуження коду в Rust не викликає подиву.


    Умови не мають дужок! Чи потрібні вони нам взагалі? Тепер наша логіка виглядає красиво і чисто.


    Всі ваші звичні реляційні та логічні оператори все ще працюють: `==`, `!=`, `<`, `>`, `<=`, `>=`, `!`, `||`, `&&`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20if%20x%20%3C%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22менше%20ніж%2042%22)%3B%0A%20%20%20%20%7D%20else%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20println!(%22це%2042%22)%3B%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22більшеr%20ніж%2042%22)%3B%0A%20%20%20%20%7D%0A%7D

- title: loop
  content_markdown: |
    Потрібен нескінченний цикл?

    Rust робить це легко.

    `break` вийде з циклу, коли ви будете готові.

    У `loop` є секрет, про який ми скоро розповімо.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A

- title: while
  content_markdown: |
    `while` дозволяє легко додати умову до циклу.

    Якщо умова набуває значення `false`, то відбувається вихід з циклу.
  code: >-
        https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20while%20x%20!%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%7D%0A%20%20%20%20println!(%22x%20це%20%7B%7D%22%2C%20x)%3B%0A%7D%0A
- title: for
  content_markdown: >
    Цикл `for` у Rust - це потужне покращення. Він перебирає значення з будь-якого виразу, який обчислює ітератор. Що таке ітератор? Ітератор - це об'єкт, до якого ви можете ставити питання «Який наступний елемент у вас є?», доки не залишиться жодного елемента.


    Ми розглянемо це детальніше у наступному розділі. А поки що просто знайте, що Rust дозволяє легко створювати ітератори, які генерують послідовність цілих чисел.


    Оператор `..` створює ітератор, який генерує числа від початкового числа до кінцевого, але не включаючи кінцеве число.


    Оператор `..=` створює ітератор, який генерує числа від початкового числа до включно з кінцевим числом.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20for%20x%20in%200..5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20for%20x%20in%200..%3D5%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%7D%0A%7D%0A

- title: match
  content_markdown: >
    Не вистачає інструкції switch? У Rust є неймовірно корисне ключове слово для порівняння всіх можливих умов значення і виконання шляху коду, якщо збіг істинний. Давайте подивимося, як це працює для чисел. У наступних розділах ми поговоримо про порівняння шаблонів зі складнішими даними. Обіцяю, що це буде варте того, щоб зачекати.


    `match` є вичерпним, тому всі випадки мають бути розглянуті.


    Зіставлення в поєднанні з деструкцією - це, безумовно, один з найпоширеніших патернів, який ви побачите у всій Rust.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%0A%20%20%20%20match%20x%20%7B%0A%20%20%20%20%20%20%20%200%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22знайдено%20нуль%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20ми%20можемо%20порівняти%20з%20кількома%20значеннями%0A%20%20%20%20%20%20%20%201%20%7C%202%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22знайдено%201%20або%202!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20ми%20можемо%20порівнювати%20з%20діапазонами%0A%20%20%20%20%20%20%20%203..%3D9%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22знайдено%20число%20від%203%20до%209%20включно%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20ми%20можемо%20прив'язати%20знайдене%20число%20до%20змінної%0A%20%20%20%20%20%20%20%20matched_num%20%40%2010..%3D100%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22знайдено%20%7B%7D%20число%20від%2010%20до%20100!%22%2C%20matched_num)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%2F%2F%20це%20відповідність%20за%20замовчуванням,%20яка%20повинна%20існувати,%20якщо%20не%20всі%20випадки%20обробляються%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20println!(%22знайдено%20ще%20щось!%22)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A

- title: Повернення значень з loop
  content_markdown: |
    `loop` може перерватися, щоб повернути значення.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%200%3B%0A%20%20%20%20let%20v%20%3D%20loop%20%7B%0A%20%20%20%20%20%20%20%20x%20%2B%3D%201%3B%0A%20%20%20%20%20%20%20%20if%20x%20%3D%3D%2013%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20break%20%22знайдено%2013%22%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22з%20loop%3A%20%7B%7D%22%2C%20v)%3B%0A%7D%0A

- title: Повернення значень з блокових виразів
  content_markdown: >
    `if`, `match`, функції та блоки області видимості мають унікальний спосіб повернення значень у Rust.


    Якщо останній оператор у блоці `if`, `match`, функції або області видимості є виразом без `;`, Rust поверне його як значення з блоку. Це чудовий спосіб створити лаконічну логіку, яка повертає значення, яке можна помістити у нову змінну.


    Це чудовий спосіб створити короткий вираз для отримання значення, що може бути записаний в змінну.


    Зверніть увагу, що він також дозволяє оператору `if` працювати як стислий тернарний вираз.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20example()%20-%3E%20i32%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20%2F%2F%20Тернарний%20вираз%20Rust%0A%20%20%20%20let%20v%20%3D%20if%20x%20%3C%2042%20%7B%20-1%20%7D%20else%20%7B%201%20%7D%3B%0A%20%20%20%20println!(%22з%20if%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20let%20food%20%3D%20%22гамбургер%22%3B%0A%20%20%20%20let%20result%20%3D%20match%20food%20%7B%0A%20%20%20%20%20%20%20%20%22гот-доґ%22%20%3D%3E%20%22це%20гот-доґ%22%2C%0A%20%20%20%20%20%20%20%20%2F%2F%20зверніть%20увагу,%20що%20дужки%20необов'язкові,%20якщо%20це%20лише%20один%20вираз%20повернення%0A%20%20%20%20%20%20%20%20_%20%3D%3E%20%22це%20не%20гот-доґ%22%2C%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22розпізнавання%20їжі%3A%20%7B%7D%22%2C%20result)%3B%0A%0A%20%20%20%20let%20v%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20Цей%20блок%20області%20видимості%20дозволяє%20отримати%20результат,%20не%20забруднюючи%20область%20видимості%20функції%0A%20%20%20%20%20%20%20%20let%20a%20%3D%201%3B%0A%20%20%20%20%20%20%20%20let%20b%20%3D%202%3B%0A%20%20%20%20%20%20%20%20a%20%2B%20b%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22з%20блоку%3A%20%7B%7D%22%2C%20v)%3B%0A%0A%20%20%20%20%2F%2F%20Ідіоматичний%20спосіб%20повернути%20значення%20в%20rust%20з%20функції%20в%20кінці%0A%20%20%20%20v%20%2B%204%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22з%20функції%3A%20%7B%7D%22%2C%20example())%3B%0A%7D%0A

- title: Розділ 2 - Висновки
  content_markdown: >
    Сподіваюся, я показав можливості Rust навіть у найпростіших мовних функціях. Ми поговоримо про `for` та `match` ще глибше, коли отримаємо більше знань, які дозволять нам використовувати їхні можливості. Наступного разу ми розглянемо базові структури даних Rust.
