- title: Розділ 9 - Організація та структура проєкту
  content_markdown: >
    Досі всі наші приклади коду були в одному файлі. Давайте обговоримо, як можна краще організувати наш код і зробити його доступним для інших!
- title: Модулі
  content_markdown: |
    Кожна програма або бібліотека Rust - це *crate*.

    Кожен crate складається з ієрархії *модулів*.

    Кожен crate є головним модулем.

    Модуль може містити глобальні змінні, функції, структури, ознаки або навіть інші модулі!

    У Rust немає відображення файлів до ієрархії дерева модулів 1 до 1. Ми повинні будувати дерево модулів явно вручну в нашому коді.
- title: Написання програм
  content_markdown: |
    Програма має кореневий модуль у файлі з назвою `main.rs`.
- title: Написання бібліотеки
  content_markdown: |
    Бібліотека має кореневий модуль у файлі з назвою `lib.rs`.
- title: Посилання на інші модулі та Crates
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Af64%3A%3Aconsts%3A%3API%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22Ласкаво%20просимо%20на%20майданчик!%22)%3B%0A%20%20%20%20println!(%22Я%20б%20не%20відмовився%20від%20шматочка%20%7B%7D!%22%2C%20PI)%3B%0A%7D%0A
  content_markdown: >
    На елементи у модулях можна посилатися за повним шляхом до модуля `std::f64::consts::PI`.


    Більш простим способом є ключове слово **use**. Воно дозволяє нам вказати певні елементи з модулів, які ми хочемо використовувати в нашому коді, без повного шляху до них. Наприклад, `use std::f64::consts::PI` дозволяє мені просто використовувати ідентифікатор `PI` у моїй головній функції.

    дозволить використовувати мені `PI` у моїх функціях.

    **std** - це ящик **стандартної бібліотеки** Rust, який містить безліч корисних структур даних і функцій для взаємодії з вашою операційною системою.


    Каталог ящиків, створених спільнотою, з можливістю пошуку можна знайти на [https://crates.io](https://crates.io/).
- title: Посилання на кілька елементів
  content_markdown: |
    Так можна посилатися на декілька елементів в одному шляху до модуля:

    ```rust
    use std::f64::consts::{PI,TAU}
    ```

    Ферріс не їсть TAU, він їсть тільки PI.
- title: Створення модулів
  content_markdown: |
    Коли ми думаємо про код, то зазвичай уявляємо собі ієрархію файлів, організованих
    у каталогах. Rust дозволяє створювати модулі, тісно пов'язані з вашою файловою
    структурою вашого файлу.

    У Rust є два способи оголошення модуля. Наприклад, модуль
    `foo` може бути представлений як:
      * файлу з іменем `foo.rs`.
      * директорія з іменем `foo` з файлом `mod.rs` всередині.
- title: Ієрархія модулів
  content_markdown: >
    Модуль може залежати від іншого модуля. Для того, щоб встановити зв'язок між модулем і його підмодулем, необхідно вписати батьківський модуль:


    ```rust

    mod foo;

    ```

    Наведений вище оголошення шукатиме файл з іменем `foo.rs` або `foo/mod.rs` і вставить його вміст у модуль з іменем `foo` у цій області видимості.
- title: Вбудований модуль
  content_markdown: >
    Підмодуль можна безпосередньо вставити в код модуля.


    Одне з найпоширеніших застосувань вбудованих модулів - це створення модульних тестів. Ми створюємо вбудований модуль, який існує лише тоді, коли для тестування використовується Rust!


    ```

    // Цей макрос видаляє цей вбудований модуль, коли Rust

    // не перебуває у тестовому режимі.

    #[cfg(test)]

    mod tests {
        // Зверніть увагу, що ми не отримуємо доступ до
        // батьківського модуля одразу. Ми повинні бути явними.
        use super::*;

        ... тести тут ...
    }

    ```
- title: Внутрішні посилання на модулі
  content_markdown: >
    У Rust є кілька ключових слів, які ви можете використовувати у вашому шляху `use` для швидкого доступу до потрібного модуля:
      
    * `crate` - кореневий модуль вашої збірки

    * `super` - батьківський модуль вашого поточного модуля

    * `self` - поточний модуль
- title: Експорт
  content_markdown: >
    За замовчуванням члени *module* недоступні ззовні модуля (навіть для його дочірніх модулів!). Ми робимо члени модуля доступними за допомогою ключового слова `pub`.


    За замовчуванням члени *crate* недоступні за межами crate. Ми робимо члени crate доступними, позначивши їх як `pub` у *кореневому модулі* вашого crate (`lib.rs` або `main.rs`).

- title: Видимість структури
  content_markdown: >
    Так само, як і функції, структури можуть оголошувати те, що вони хочуть бачити за межами свого модуля, використовуючи `pub`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Структура%20SeaCreature%20буде%20доступна%20з%20інших%20модулів%0Apub%20struct%20SeaCreature%20%7B%0A%20%20%20%20pub%20animal_type%3A%20String%2C%0A%20%20%20%20pub%20name%3A%20String%2C%0A%20%20%20%20pub%20arms%3A%20i32%2C%0A%20%20%20%20pub%20legs%3A%20i32%2C%0A%20%20%20%20%2F%2F%20Залишимо%20нашу%20зброю%20приватною%0A%20%20%20%20weapon%3A%20String%2C%0A%7D%0A
- title: Prelude
  content_markdown: |
    Ви можете задуматися, як ми маємо доступ до `Vec` або `Box` всюди без явного `use` для їх імпорту. Це завдяки модулю `prelude` у стандартній бібліотеці.

    Знайте, що в стандартній бібліотеці Rust усе, що експортується в `std::prelude::*`, автоматично доступне у будь-якій частині Rust. Це стосується `Vec` і `Box`, а також інших (наприклад, `Option`, `Copy` тощо).
- title: Ваша власна Prelude
  content_markdown: >
    Через наявність `prelude` у стандартній бібліотеці є звичною практикою, щоб ваша бібліотека також мала власний модуль `prelude` як відправну точку. Користувачі мають імпортувати з нього всі найпоширеніші структури даних для використання вашої бібліотеки (наприклад, `use my_library::prelude::*`). Цей модуль не підключається автоматично у програмах чи бібліотеках, що використовують ваш crate, але це хороша практика, яка допомагає користувачам зрозуміти, з чого почати.

    Ферріс каже: "Будь хорошим rustacean (іржавцем) і допоможи товаришу-крабу з гарним `prelude`!"
- title: Розділ 9 - Висновки
  content_markdown: >
    Тепер у вас є кілька хитрощів у запасі, коли справа доходить до створення Rust-застосунків і бібліотек, готових до використання у світі.

    Не хвилюйтеся, якщо не запам’ятаєте все одразу. У міру того, як ваша бібліотека зростатиме й використовуватиметься іншими людьми, ви поступово знайдете найкращі підходи на кожному етапі.

    Ресурси:
    - [Рекомендації щодо написання Rust API](https://rust-lang.github.io/api-guidelines/)
