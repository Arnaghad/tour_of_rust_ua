- title: Розділ 4 - Загальні типи
  content_markdown: >
    Загальні типи є неймовірно важливими у Rust. Вони використовуються для представлення нульових значень (тобто змінних, які ще не мають значення), обробки помилок, колекцій та багато іншого! У цьому розділі ми познайомимося з основними загальні типи, які ви, ймовірно, будете використовувати постійно.

- title: Що таке загальні типи?
  content_markdown: >
    Загальні типи дозволяють нам частково визначити `struct` або `enum`, що дозволяє компілятору створити повністю визначену версію під час компіляції на основі використання нашого коду.


    Rust зазвичай може визначити кінцевий тип, дивлячись на наші екземпляри, але якщо йому потрібна допомога, ви завжди можете використати оператор `::<T>`, також відомий під назвою `turbofish` (він є моїм добрим другом!).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Частково%20визначений%20тип%20структури%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20item%3A%20T%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Примітка%3A%20використовуючи%20тут%20загальні%20типи%2C%20ми%20створюємо%20типи%2C%20створені%20під%20час%20компіляції.%20%0A%20%20%20%20%2F%2F%20Turbofish%20дозволяє%20нам%20бути%20зрозумілими.%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%2042%20%7D%3B%0A%20%20%20%20let%20bool_bag%20%3D%20BagOfHolding%3A%3A%3Cbool%3E%20%7B%20item%3A%20true%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Rust%20також%20може%20визначати%20загальний%20тип%21%0A%20%20%20%20let%20float_bag%20%3D%20BagOfHolding%20%7B%20item%3A%203.14%20%7D%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20Примітка%3A%20ніколи%20не%20кладіть%20пакет%20для%20утримання%20в%20пакет%20для%20утримання%20в%20реальному%20житті%0A%20%20%20%20let%20bag_in_bag%20%3D%20BagOfHolding%20%7B%0A%20%20%20%20%20%20%20%20item%3A%20BagOfHolding%20%7B%20item%3A%20%22boom%21%22%20%7D%2C%0A%20%20%20%20%7D%3B%0A%0A%20%20%20%20println%21%28%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20i32_bag.item%2C%20bool_bag.item%2C%20float_bag.item%2C%20bag_in_bag.item.item%0A%20%20%20%20%29%3B%0A%7D

- title: Представлення нічого
  content_markdown: >
    В інших мовах для позначення відсутності значення використовується ключове слово `null`. Це створює труднощі у мовах програмування, оскільки створює можливість того, що наша програма може зазнати невдачі при взаємодії зі змінною/полем.


    Rust не має `null`, але він не ігнорує важливість представлення нічого! Розглянемо наївне представлення за допомогою вже знайомого нам інструменту.


    Цей шаблон надання альтернативного представлення `None` для одного або декількох альтернативних значень є дуже поширеним у Rust через відсутність у ньому значення `null`. Загальні типи допомагають вирішити цю проблему.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=enum%20Item%20%7B%0A%20%20%20%20Inventory(String)%2C%0A%20%20%20%20%2F%2F%20None%20означає%20відсутність%20елемента%0A%20%20%20%20None%2C%0A%7D%0A%0Astruct%20BagOfHolding%20%7B%0A%20%20%20%20item%3A%20Item%2C%0A%7D%0A

- title: Option
  content_markdown: >
    Rust має вбудований загальний зчислювач, який називається `Option`, що дозволяє представляти нульові значення без використання `null`.

    ```

    enum Option<T> {
        None,
        Some(T),
    }

    ```

    Це зчислення настільки поширене, що екземпляри цього зчислення можна створювати будь-де з варіантами зчислення `Some` та `None`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20Частково%20визначений%20тип%20структури%0Astruct%20BagOfHolding%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20Наш%20параметр%20типу%20T%20може%20бути%20переданий%20іншим%0A%20%20%20%20item%3A%20Option%3CT%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Примітка%3A%20Мішок%20для%20i32%2C%20який%20нічого%20не%20містить!%20Ми%20повинні%20вказати%20тип%0A%20%20%20%20%2F%2F%20бо%20інакше%20Rust%20не%20знатиме%2C%20який%20це%20тип%20мішка.%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20None%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_none()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22У%20мішку%20нічого%20немає!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22У%20мішку%20щось%20є!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20let%20i32_bag%20%3D%20BagOfHolding%3A%3A%3Ci32%3E%20%7B%20item%3A%20Some(42)%20%7D%3B%0A%0A%20%20%20%20if%20i32_bag.item.is_some()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22У%20мішку%20щось%20є!%22)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20println!(%22У%20мішку%20нічого%20немає!%22)%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20match%20дозволяє%20нам%20елегантно%20розібрати%20Option%20і%20впевнитися%2C%20що%20ми%20обробили%20всі%20випадки!%0A%20%20%20%20match%20i32_bag.item%20%7B%0A%20%20%20%20%20%20%20%20Some(v)%20%3D%3E%20println!(%22Знайдено%20%7B%7D%20у%20мішку!%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20None%20%3D%3E%20println!(%22Нічого%20не%20знайдено%22)%2C%0A%20%20%20%20%7D%0A%7D

- title: Result
  content_markdown: >
    Rust має вбудоване загальне перелічування під назвою `Result`, яке дозволяє нам повертати значення, яке може бути помилковим. Це ідіоматичний спосіб, яким мова обробляє помилки.

    ```

    enum Result<T, E> {
        Ok(T),
        Err(E),
    }

    ```

    Зверніть увагу, що наш загальний тип має декілька *параметризованих типів*, розділених комою. Це перелічення настільки поширене, що його екземпляри можна створювати будь-де з варіантами переліку `Ok` та `Err`.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3Ai32)%20-%3E%20Result%3Cf32%2CString%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22це%20не%20правильне%20число%22))%20%20%20%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20%2F%2F%20match%20дозволяє%20нам%20елегантно%20розібрати%20Result%20і%20впевнитися%2C%20що%20ми%20обробили%20всі%20випадки!%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22знайдено%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(e)%20%3D%3E%20println!(%22Помилка%3A%20%7B%7D%22%2Ce)%2C%0A%20%20%20%20%7D%0A%7D

- title: Main, що може завершитися помилкою
  content_markdown: |
    `main` має можливість повертати `Result`!
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22%D1%86%D0%B5%20%D0%BD%D0%B5%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%22))%0A%20%20%20%20%7D%0A%7D%0A%0A%2F%2F%20%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%8F%20main%20%D0%BD%D1%96%D1%87%D0%BE%D0%B3%D0%BE%20%D0%BD%D0%B5%20%D0%BF%D0%BE%D0%B2%D0%B5%D1%80%D1%82%D0%B0%D1%94%2C%20%D0%B0%D0%BB%D0%B5%20%D0%BC%D0%BE%D0%B6%D0%B5%20%D0%BF%D0%BE%D0%B2%D0%B5%D1%80%D0%BD%D1%83%D1%82%D0%B8%20%D0%BF%D0%BE%D0%BC%D0%B8%D0%BB%D0%BA%D1%83!%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20let%20result%20%3D%20do_something_that_might_fail(12)%3B%0A%0A%20%20%20%20match%20result%20%7B%0A%20%20%20%20%20%20%20%20Ok(v)%20%3D%3E%20println!(%22%D0%B7%D0%BD%D0%B0%D0%B9%D0%B4%D0%B5%D0%BD%D0%BE%20%7B%7D%22%2C%20v)%2C%0A%20%20%20%20%20%20%20%20Err(_e)%20%3D%3E%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%D0%BE%D0%B1%D1%80%D0%BE%D0%B1%D0%BB%D1%8F%D1%94%D0%BC%D0%BE%20%D1%86%D1%8E%20%D0%BF%D0%BE%D0%BC%D0%B8%D0%BB%D0%BA%D1%83%20%D0%B0%D0%BA%D1%83%D1%80%D0%B0%D1%82%D0%BD%D0%BE%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20%D0%BF%D0%BE%D0%B2%D0%B5%D1%80%D1%82%D0%B0%D1%94%D0%BC%D0%BE%20%D0%BD%D0%BE%D0%B2%D1%83%20%D0%BF%D0%BE%D0%BC%D0%B8%D0%BB%D0%BA%D1%83%20%D0%B7%20main%2C%20%D1%8F%D0%BA%D0%B0%20%D0%B2%D0%BA%D0%B0%D0%B7%D1%83%D1%94%2C%20%D1%89%D0%BE%20%D1%82%D1%80%D0%B0%D0%BF%D0%B8%D0%BB%D0%BE%D1%81%D1%8C!%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20Err(String%3A%3Afrom(%22%D1%89%D0%BE%D1%81%D1%8C%20%D0%BF%D1%96%D1%88%D0%BB%D0%BE%20%D0%BD%D0%B5%20%D1%82%D0%B0%D0%BA%20%D1%83%20main!%22))%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%2F%2F%20%D0%97%D0%B2%D0%B5%D1%80%D0%BD%D1%96%D1%82%D1%8C%20%D1%83%D0%B2%D0%B0%D0%B3%D1%83%2C%20%D1%89%D0%BE%20%D0%BC%D0%B8%20%D0%B2%D0%B8%D0%BA%D0%BE%D1%80%D0%B8%D1%81%D1%82%D0%BE%D0%B2%D1%83%D1%94%D0%BC%D0%BE%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D1%8F%20unit%20%D1%83%20Result%20Ok%2C%0A%20%20%20%20%2F%2F%20%D1%89%D0%BE%D0%B1%20%D0%BF%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%B8%D1%82%D0%B8%2C%20%D1%89%D0%BE%20%D0%B2%D1%81%D0%B5%20%D0%B4%D0%BE%D0%B1%D1%80%D0%B5%0A%20%20%20%20Ok(())%0A%7D%0A

- title: Витончена обробка помилок
  content_markdown: >
    `Result` є настільки поширеним, що у Rust є потужний оператор `?` для роботи з ними. Ці два оператори еквівалентні:

    ```

    do_something_that_might_fail()?

    ```


    ```

    match do_something_that_might_fail() {
        Ok(v) => v,
        Err(e) => return Err(e),
    }

    ```
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22%D1%86%D0%B5%20%D0%BD%D0%B5%20%D0%B2%D1%96%D1%80%D0%BD%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20%D0%9F%D0%BE%D0%B4%D0%B8%D0%B2%D1%96%D1%82%D1%8C%D1%81%D1%8F%2C%20%D1%81%D0%BA%D1%96%D0%BB%D1%8C%D0%BA%D0%B8%20%D0%BA%D0%BE%D0%B4%D1%83%20%D0%BC%D0%B8%20%D0%B7%D0%B5%D0%BA%D0%BE%D0%BD%D0%BE%D0%BC%D0%B8%D0%BB%D0%B8!%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42)%3F%3B%0A%20%20%20%20println!(%22%D0%B7%D0%BD%D0%B0%D0%B9%D0%B4%D0%B5%D0%BD%D0%BE%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20Ok(())%0A%7D%0A

- title: Обробка потворних Option/Result
  content_markdown: >
    Робота з `Option`/`Result` може бути нудною, коли ви просто намагаєтеся написати швидкий код.  І `Option`, і `Result` мають функцію `unwrap`, яка може бути корисною для швидкого і брудного отримання значення.  Функція `unwrap` зробить це:

    1. Отримати значення всередині Option/Result

    2. Якщо перерахування має тип None/Err, то `panic!`


    Ці два фрагменти коду еквівалентні:


    ```

    my_option.unwrap()

    ```


    ```

    match my_option {
        Some(v) => v,
        None => panic!("якесь повідомлення про помилку, згенероване Rust!"),
    }

    ```


    Аналогічно:


    ```

    my_result.unwrap()

    ```


    ```

    match my_result {
        Ok(v) => v,
        Err(e) => panic!("якесь повідомлення про помилку, згенероване Rust!"),
    }

    ```

    Будьте добрим rustacean і правильно використовуйте `match`, коли можете!
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20do_something_that_might_fail(i%3A%20i32)%20-%3E%20Result%3Cf32%2C%20String%3E%20%7B%0A%20%20%20%20if%20i%20%3D%3D%2042%20%7B%0A%20%20%20%20%20%20%20%20Ok(13.0)%0A%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20Err(String%3A%3Afrom(%22%D1%86%D0%B5%20%D0%BD%D0%B5%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%B5%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%22))%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20-%3E%20Result%3C()%2C%20String%3E%20%7B%0A%20%20%20%20%2F%2F%20%D0%BB%D0%B0%D0%BA%D0%BE%D0%BD%D1%96%D1%87%D0%BD%D0%BE%2C%20%D0%B0%D0%BB%D0%B5%20%D0%BD%D0%B5%D0%B1%D0%B5%D0%B7%D0%BF%D0%B5%D1%87%D0%BD%D0%BE%20%D1%96%20%D1%88%D0%B2%D0%B8%D0%B4%D0%BA%D0%BE%20%D0%BF%D0%B5%D1%80%D0%B5%D1%82%D0%B2%D0%BE%D1%80%D1%8E%D1%94%D1%82%D1%8C%D1%81%D1%8F%20%D0%BD%D0%B0%20%D0%BA%D0%B0%D1%82%D0%B0%D1%81%D1%82%D1%80%D0%BE%D1%84%D1%83%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(42).unwrap()%3B%0A%20%20%20%20println!(%22%D0%B7%D0%BD%D0%B0%D0%B9%D0%B4%D0%B5%D0%BD%D0%BE%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20%D1%86%D0%B5%20%D0%B2%D0%B8%D0%BA%D0%BB%D0%B8%D0%BA%D0%B0%D1%94%20panic!%0A%20%20%20%20let%20v%20%3D%20do_something_that_might_fail(1).unwrap()%3B%0A%20%20%20%20println!(%22%D0%B7%D0%BD%D0%B0%D0%B9%D0%B4%D0%B5%D0%BD%D0%BE%20%7B%7D%22%2C%20v)%3B%0A%20%20%20%20%0A%20%20%20%20Ok(())%0A%7D%0A

- title: Вектори
  content_markdown: >
    Одними з найкорисніших загальних типів є типи колекцій. Вектор - це список елементів змінного розміру, представлений структурою `Vec`.


    Макрос `vec!` дозволяє нам легко створити вектор замість того, щоб будувати його вручну.


    У `Vec` є метод `iter()`, який створює ітератор з вектора, що дозволяє легко помістити вектор у цикл `for`.


    Деталі пам'яті:

    * Vec - це структура, але всередині вона містить посилання на фіксований список своїх елементів у купі.

    * Вектор починається зі стандартною ємністю; коли додається більше елементів, ніж він може вмістити, він перерозподіляє свої дані у купі, щоб отримати новий фіксований список з більшою ємністю.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%D0%9C%D0%B8%20%D0%BC%D0%BE%D0%B6%D0%B5%D0%BC%D0%BE%20%D1%8F%D0%B2%D0%BD%D0%BE%20%D0%B2%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B8%20%D1%82%D0%B8%D0%BF%0A%20%20%20%20let%20mut%20i32_vec%20%3D%20Vec%3A%3A%3Ci32%3E%3A%3Anew()%3B%20%2F%2F%20turbofish%20%3C3%0A%20%20%20%20i32_vec.push(1)%3B%0A%20%20%20%20i32_vec.push(2)%3B%0A%20%20%20%20i32_vec.push(3)%3B%0A%0A%20%20%20%20%2F%2F%20%D0%90%D0%BB%D0%B5%20%D0%BF%D0%BE%D0%B4%D0%B8%D0%B2%D1%96%D1%82%D1%8C%D1%81%D1%8F%2C%20%D0%BD%D0%B0%D1%81%D0%BA%D1%96%D0%BB%D1%8C%D0%BA%D0%B8%20Rust%20%D1%80%D0%BE%D0%B7%D1%83%D0%BC%D0%BD%D0%B8%D0%B9%20%D1%83%20%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%BC%D1%83%20%D0%B2%D0%B8%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D1%96%20%D1%82%D0%B8%D0%BF%D1%83%0A%20%20%20%20let%20mut%20float_vec%20%3D%20Vec%3A%3Anew()%3B%0A%20%20%20%20float_vec.push(1.3)%3B%0A%20%20%20%20float_vec.push(2.3)%3B%0A%20%20%20%20float_vec.push(3.4)%3B%0A%0A%20%20%20%20%2F%2F%20%D0%A6%D0%B5%20%D0%BF%D1%80%D0%B5%D0%BA%D1%80%D0%B0%D1%81%D0%BD%D0%B8%D0%B9%20%D0%BC%D0%B0%D0%BA%D1%80%D0%BE%D1%81!%0A%20%20%20%20let%20string_vec%20%3D%20vec!%5BString%3A%3Afrom(%22%D0%9F%D1%80%D0%B8%D0%B2%D1%96%D1%82%22)%2C%20String%3A%3Afrom(%22%D0%A1%D0%B2%D1%96%D1%82%22)%5D%3B%0A%0A%20%20%20%20for%20word%20in%20string_vec.iter()%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20word)%3B%0A%20%20%20%20%7D%0A%7D%0A

- title: Розділ 4 - Висновки
  content_markdown: >
    В одному розділі ми дізналися, як багато можливостей дають нам загальні типи! Не хвилюйтеся, якщо ви не знаєте, як все це використовувати, зараз просто корисно знати основні ідеї, які ви будете зустрічати в коді знову і знову. Наші функції стають досить довгими! У нашій наступній главі ми поговоримо про важливу концепцію в Rust: право власності на дані (data ownership).
