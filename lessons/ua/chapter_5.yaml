- title: Розділ 5 - Власність та Позичання Даних
  content_markdown: >
    Rust має унікальну парадигму керування пам'яттю порівняно з іншими мовами програмування. Ми розглянемо поведінку та перевірки компілятора по черзі, щоб не перевантажувати вас. Важливо пам'ятати, що правила, які ми показуємо, існують не для того, щоб ускладнити вам життя, а для того, щоб допомогти вам зробити ваш код менш схильним до помилок!
- title: Власність
  content_markdown: >
    Створення екземпляра типу і **прив'язування** його до імені змінної створює ресурс пам'яті, який компілятор Rust буде перевіряти протягом усього **життєвого циклу**.  Прив'язана змінна називається **власником** ресурсу.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20Ми%20створюємо%20екземпляр%20структури%20та%20прив'язуємо%20його%20до%20змінної%0A%20%20%20%20%2F%2F%20для%20створення%20ресурсу%20пам'яті%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20є%20власником%0A%7D%0A
- title: Управління ресурсами на основі обсягу робіт
  content_markdown: |
    Rust використовує кінець області видимості як місце для деконструкції та перерозподілу ресурсу.


    Термін для такої деконструкції та вивільнення називається **скидання**.


    Детальна інформація про пам'ять:

    * У Rust не передбачено збирання сміття.

    * Це також називається «Отримання ресурсу є ініціалізацією» (Resource Acquisition Is Initialization, RAII) у C++.
  code: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2013%20%7D%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20%2F%2F%20foo_b%20звільняється%20тут%20%0A%20%20%20%20%2F%2F%20foo_a%20звільняється%20тут%0A%7D%0A

- title: Скидання є ієрархічним
  content_markdown: >
    Коли структура скидається, спочатку скидається сама структура, потім її дочірні структури, і так далі.


    Подробиці про пам'ять:

    * Автоматично звільняючи пам'ять, Rust допомагає зменшити кількість витоків пам'яті.

    * Ресурси пам'яті можна скинути лише один раз.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Bar%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Astruct%20Foo%20%7B%0A%20%20%20%20bar%3A%20Bar%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20bar%3A%20Bar%20%7B%20x%3A%2042%20%7D%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.bar.x)%3B%0A%20%20%20%20%2F%2F%20Спочатку%20скидається%20foo%0A%20%20%20%20%2F%2F%20Потім%20скидається%20foo.bar%0A%7D%0A
- title: Переміщення права власності
  content_markdown: >
    Коли власник передається як аргумент у функцію, власність переміщується на параметр функції.


    Після **переміщення** змінна у вихідній функції більше не може бути використана.


    Деталі пам'яті:

    * Під час **переміщення** стекова пам'ять значення власника копіюється до стекової пам'яті параметра виклику функції.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20скидається%20тут%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20%2F%2F%20foo%20переміщується%20в%20do_something%0A%20%20%20%20do_something(foo)%3B%0A%20%20%20%20%2F%2F%20foo%20більше%20не%20можна%20використовувати%0A%7D%0A
- title: Повернення права власності
  content_markdown: |
    Право власності також можна повернути з функції.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something()%20-%3E%20Foo%20%7B%0A%20%20%20%20Foo%20%7B%20x%3A%2042%20%7D%0A%20%20%20%20%2F%2F%20право%20власності%20переміщується%20назовні%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20do_something()%3B%0A%20%20%20%20%2F%2F%20foo%20стає%20власником%0A%20%20%20%20%2F%2F%20foo%20скидається%20через%20завершення%20області%20видимості%20функції%0A%7D%0A
- title: Запозичення права власності з посиланнями
  content_markdown: |
    Посилання дозволяють нам запозичувати доступ до ресурсу за допомогою оператора `&`.


    Посилання також скидаються, як і інші ресурси.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26foo%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20скидається%20тут%0A%20%20%20%20%2F%2F%20foo%20скидається%20тут%0A%7D%0A
- title: Запозичення змінного права власності з посиланнями
  content_markdown: >
    Ми також можемо запозичити змінюваний доступ до ресурсу за допомогою оператора `&mut`.


    Власник ресурсу не може бути переміщений або змінений під час взаємного запозичення.


    Подробиці про пам'ять:

    * Rust не дозволяє мати два способи змінення власного значення, оскільки це призводить до можливості перегонів даних.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20Foo)%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20f.x)%3B%0A%20%20%20%20%2F%2F%20f%20%D0%B2%D0%B8%D0%B4%D0%B0%D0%BB%D1%8F%D1%94%D1%82%D1%8C%D1%81%D1%8F%20%D1%82%D1%83%D1%82%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%0A%20%20%20%20%2F%2F%20%D0%9F%D0%9E%D0%9C%D0%98%D0%9B%D0%9A%D0%90%3A%20do_something(foo)%20%D0%BD%D0%B5%20%D1%81%D0%BF%D1%80%D0%B0%D1%86%D1%8E%D1%94%2C%20%D1%82%D0%BE%D0%BC%D1%83%20%D1%89%D0%BE%0A%20%20%20%20%2F%2F%20foo%20%D0%BD%D0%B5%20%D0%BC%D0%BE%D0%B6%D0%B5%20%D0%B1%D1%83%D1%82%D0%B8%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D1%96%D1%89%D0%B5%D0%BD%D0%BE%2C%20%D0%BF%D0%BE%D0%BA%D0%B8%20%D0%B2%D0%BE%D0%BD%D0%BE%20%D0%BF%D0%BE%D0%B7%D0%B8%D1%87%D0%B5%D0%BD%D0%BE%20%D0%B7%20%D0%BC%D0%BE%D0%B6%D0%BB%D0%B8%D0%B2%D1%96%D1%81%D1%82%D1%8E%20%D0%B7%D0%BC%D1%96%D0%BD%D0%B8%0A%0A%20%20%20%20%2F%2F%20%D0%9F%D0%9E%D0%9C%D0%98%D0%9B%D0%9A%D0%90%3A%20foo.x%20%3D%2013%3B%20%D0%BD%D0%B5%20%D1%81%D0%BF%D1%80%D0%B0%D1%86%D1%8E%D1%94%20%D1%82%D1%83%D1%82%2C%20%D1%82%D0%BE%D0%BC%D1%83%20%D1%89%D0%BE%0A%20%20%20%20%2F%2F%20foo%20%D0%BD%D0%B5%20%D0%BC%D0%BE%D0%B6%D0%B5%20%D0%B1%D1%83%D1%82%D0%B8%20%D0%B7%D0%BC%D1%96%D0%BD%D0%B5%D0%BD%D0%BE%2C%20%D0%BF%D0%BE%D0%BA%D0%B8%20%D0%B2%D0%BE%D0%BD%D0%BE%20%D0%BF%D0%BE%D0%B7%D0%B8%D1%87%D0%B5%D0%BD%D0%BE%20%D0%B7%20%D0%BC%D0%BE%D0%B6%D0%BB%D0%B8%D0%B2%D1%96%D1%81%D1%82%D1%8E%20%D0%B7%D0%BC%D1%96%D0%BD%D0%B8%0A%0A%20%20%20%20f.x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20f%20%D0%B2%D0%B8%D0%B4%D0%B0%D0%BB%D1%8F%D1%94%D1%82%D1%8C%D1%81%D1%8F%20%D1%82%D1%83%D1%82%2C%20%D1%82%D0%BE%D0%BC%D1%83%20%D1%89%D0%BE%20%D0%B2%D0%BE%D0%BD%D0%BE%20%D0%B1%D1%96%D0%BB%D1%8C%D1%88%D0%B5%20%D0%BD%D0%B5%20%D0%B2%D0%B8%D0%BA%D0%BE%D1%80%D0%B8%D1%81%D1%82%D0%BE%D0%B2%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%20%D0%BF%D1%96%D1%81%D0%BB%D1%8F%20%D1%86%D1%8C%D0%BE%D0%B3%D0%BE%20%D0%BC%D0%BE%D0%BC%D0%B5%D0%BD%D1%82%D1%83%0A%20%20%20%20%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo.x)%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20%D1%86%D0%B5%20%D0%BF%D1%80%D0%B0%D1%86%D1%8E%D1%94%20%D1%82%D0%B5%D0%BF%D0%B5%D1%80%2C%20%D1%82%D0%BE%D0%BC%D1%83%20%D1%89%D0%BE%20%D0%B2%D1%81%D1%96%20%D0%BF%D0%BE%D1%81%D0%B8%D0%BB%D0%B0%D0%BD%D0%BD%D1%8F%20%D0%B7%20%D0%BC%D0%BE%D0%B6%D0%BB%D0%B8%D0%B2%D1%96%D1%81%D1%82%D1%8E%20%D0%B7%D0%BC%D1%96%D0%BD%D0%B8%20%D0%B1%D1%83%D0%BB%D0%B8%20%D0%B2%D0%B8%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D1%96%0A%20%20%20%20foo.x%20%3D%207%3B%0A%20%20%20%20%0A%20%20%20%20%2F%2F%20%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B0%20%D0%B2%D0%BE%D0%BB%D0%BE%D0%B4%D1%96%D0%BD%D0%BD%D1%8F%20foo%20%D1%83%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%8E%0A%20%20%20%20do_something(foo)%3B%0A%7D%0A
- title: Видалення посилань
  content_markdown: >
    Використовуючи посилання `&mut`, ви можете встановити значення власника за допомогою оператора `*`.


    Ви також можете отримати копію значення власника за допомогою оператора `*` (якщо значення може бути скопійоване - ми обговоримо копійовані типи у наступних розділах).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20%26mut%20foo%3B%0A%20%20%20%20let%20bar%20%3D%20*f%3B%20%2F%2F%20%D0%BE%D1%82%D1%80%D0%B8%D0%BC%D0%B0%D1%82%D0%B8%20%D0%BA%D0%BE%D0%BF%D1%96%D1%8E%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D1%8F%20%D0%B2%D0%BB%D0%B0%D1%81%D0%BD%D0%B8%D0%BA%D0%B0%0A%20%20%20%20*f%20%3D%2013%3B%20%20%20%20%20%20%2F%2F%20%D0%B2%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D0%B8%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D1%8F%20%D0%B2%D0%BB%D0%B0%D1%81%D0%BD%D0%B8%D0%BA%D0%B0%20%D0%BF%D0%BE%D1%81%D0%B8%D0%BB%D0%B0%D0%BD%D0%BD%D1%8F%0A%20%20%20%20println!(%22%7B%7D%22%2C%20bar)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo)%3B%0A%7D%0A
- title: Передача запозичених даних
  content_markdown: >
    Правила Rust для посилань можна підсумувати наступним чином:

    * Rust допускає існування лише одного змінюваного посилання **або** кількох незмінюваних посилань **але не обох разом**.

    * Посилання ніколи не повинно **жити довше**, ніж його власник.


    Це, як правило, не є проблемою при передачі посилань на функції.


    Подробиці про пам'ять:

    * Перше правило роботи з посиланнями запобігає перегонам даних. Що таке перегони даних? Перегони даних при читанні з даних можуть бути несинхронними через те, що в той самий час відбувається запис до даних. Це часто трапляється у багатопотоковому програмуванні.

    * Друге правило посилань запобігає зловживанню посиланнями, які посилаються на неіснуючі дані (так звані «бовтаючі вказівники» у C).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(f%3A%20%26mut%20Foo)%20%7B%0A%20%20%20%20f.x%20%2B%3D%201%3B%0A%20%20%20%20%2F%2F%20%D0%B7%D0%BC%D1%96%D0%BD%D1%8E%D0%B2%D0%B0%D0%BD%D0%B5%20%D0%BF%D0%BE%D1%81%D0%B8%D0%BB%D0%B0%D0%BD%D0%BD%D1%8F%20f%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20%D0%BE%D1%81%D0%BA%D1%96%D0%BB%D1%8C%D0%BA%D0%B8%20%D0%B2%D1%81%D1%96%20%D0%B7%D0%BC%D1%96%D0%BD%D1%8E%D0%B2%D0%B0%D0%BD%D1%96%20%D0%BF%D0%BE%D1%81%D0%B8%D0%BB%D0%B0%D0%BD%D0%BD%D1%8F%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%8E%D1%82%D1%8C%D1%81%D1%8F%20%D0%B2%D1%81%D0%B5%D1%80%D0%B5%D0%B4%D0%B8%D0%BD%D1%96%0A%20%20%20%20%2F%2F%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%97%20do_something,%20%D0%BC%D0%B8%20%D0%BC%D0%BE%D0%B6%D0%B5%D0%BC%D0%BE%20%D1%81%D1%82%D0%B2%D0%BE%D1%80%D0%B8%D1%82%D0%B8%20%D1%89%D0%B5%20%D0%BE%D0%B4%D0%BD%D0%B5.%0A%20%20%20%20do_something(%26mut%20foo)%3B%0A%20%20%20%20%2F%2F%20foo%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%0A%7D%0A
- title: Посилання на посилання
  content_markdown: |
    Посилання можна використовувати навіть у фрагментах посилань.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0Afn%20do_something(a%3A%20%26Foo)%20-%3E%20%26i32%20%7B%0A%20%20%20%20return%20%26a.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%2C%20%D1%89%D0%BE%20%D0%B4%D0%BE%D0%B7%D0%B2%D0%BE%D0%BB%D1%8F%D1%94%20%D1%81%D1%82%D0%B2%D0%BE%D1%80%D0%B8%D1%82%D0%B8%20%D0%BD%D0%B5%D0%BC%D1%83%D1%82%D0%BE%D0%B2%D0%B0%D0%BD%D0%B5%20%D0%BF%D0%BE%D1%81%D0%B8%D0%BB%D0%B0%D0%BD%D0%BD%D1%8F%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%0A%20%20%20%20%2F%2F%20foo%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%0A%7D%0A
- title: Явний час життя
  content_markdown: >
    Хоча Rust не завжди показує це у коді, компілятор розуміє час життя кожної змінної і намагатиметься перевірити, щоб посилання не існувало довше, ніж його власник.
    

    Функції можуть бути явними, якщо параметризувати сигнатуру функції за допомогою символів, які допомагають визначити, які параметри та значення, що повертаються, мають однаковий час життя.


    Специфікатори часу життя завжди починаються з `'` (наприклад, `'a`, `'b`, `'c`)
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%20foo%20%D1%82%D0%B0%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D1%8F%2C%20%D1%89%D0%BE%20%D0%BF%D0%BE%D0%B2%D0%B5%D1%80%D1%82%D0%B0%D1%94%D1%82%D1%8C%D1%81%D1%8F%2C%20%D0%BC%D0%B0%D1%8E%D1%82%D1%8C%20%D0%BE%D0%B4%D0%B8%D0%BD%20%D1%96%20%D1%82%D0%BE%D0%B9%20%D1%81%D0%B0%D0%BC%D0%B8%D0%B9%20%D1%87%D0%B0%D1%81%20%D0%B6%D0%B8%D1%82%D1%82%D1%8F%0Afn%20do_something%3C'a%3E(foo%3A%20%26'a%20Foo)%20-%3E%20%26'a%20i32%20%7B%0A%20%20%20%20return%20%26foo.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20foo%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20%26mut%20foo.x%3B%0A%20%20%20%20*x%20%3D%2013%3B%0A%20%20%20%20%2F%2F%20x%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%2C%20%D1%89%D0%BE%20%D0%B4%D0%BE%D0%B7%D0%B2%D0%BE%D0%BB%D1%8F%D1%94%20%D1%81%D1%82%D0%B2%D0%BE%D1%80%D0%B8%D1%82%D0%B8%20%D0%BD%D0%B5%D0%BC%D1%83%D1%82%D0%BE%D0%B2%D0%B0%D0%BD%D0%B5%20%D0%BF%D0%BE%D1%81%D0%B8%D0%BB%D0%B0%D0%BD%D0%BD%D1%8F%0A%20%20%20%20let%20y%20%3D%20do_something(%26foo)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20y)%3B%0A%20%20%20%20%2F%2F%20y%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%0A%20%20%20%20%2F%2F%20foo%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%0A%7D%0A
- title: Кілька часів життя
  content_markdown: >
    Специфікатори часу життя дозволяють нам чітко визначити певні сценарії, які компілятор не може розв'язати самостійно, розрізняючи всі часи життя компонентів сигнатури функції.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%20%7B%0A%20%20%20%20x%3A%20i32%2C%0A%7D%0A%0A%2F%2F%20foo_b%20%D1%82%D0%B0%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D1%8F%2C%20%D1%89%D0%BE%20%D0%BF%D0%BE%D0%B2%D0%B5%D1%80%D1%82%D0%B0%D1%94%D1%82%D1%8C%D1%81%D1%8F%2C%20%D0%BC%D0%B0%D1%8E%D1%82%D1%8C%20%D0%BE%D0%B4%D0%B8%D0%BD%20%D1%96%20%D1%82%D0%BE%D0%B9%20%D1%81%D0%B0%D0%BC%D0%B8%D0%B9%20%D1%87%D0%B0%D1%81%20%D0%B6%D0%B8%D1%82%D1%82%D1%8F%0A%2F%2F%20foo_a%20%D0%BC%D0%B0%D1%94%20%D1%96%D0%BD%D1%88%D0%B8%D0%B9%20%D1%87%D0%B0%D1%81%20%D0%B6%D0%B8%D1%82%D1%82%D1%8F%0Afn%20do_something%3C'a%2C%20'b%3E(foo_a%3A%20%26'a%20Foo%2C%20foo_b%3A%20%26'b%20Foo)%20-%3E%20%26'b%20i32%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_a.x)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20foo_b.x)%3B%0A%20%20%20%20return%20%26foo_b.x%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20foo_a%20%3D%20Foo%20%7B%20x%3A%2042%20%7D%3B%0A%20%20%20%20let%20foo_b%20%3D%20Foo%20%7B%20x%3A%2012%20%7D%3B%0A%20%20%20%20let%20x%20%3D%20do_something(%26foo_a%2C%20%26foo_b)%3B%0A%20%20%20%20%2F%2F%20foo_a%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%2C%20%D0%BE%D1%81%D0%BA%D1%96%D0%BB%D1%8C%D0%BA%D0%B8%20%D0%BB%D0%B8%D1%88%D0%B5%20%D1%87%D0%B0%D1%81%20%D0%B6%D0%B8%D1%82%D1%82%D1%8F%20foo_b%20%D1%96%D1%81%D0%BD%D1%83%D1%94%20%D0%BF%D1%96%D1%81%D0%BB%D1%8F%20%D1%86%D1%8C%D0%BE%D0%B3%D0%BE%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20%2F%2F%20x%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%0A%20%20%20%20%2F%2F%20foo_b%20%D1%82%D1%83%D1%82%20%D1%81%D0%BA%D0%B8%D0%B4%D1%83%D1%94%D1%82%D1%8C%D1%81%D1%8F%0A%7D%0A
- title: Статичний час життя
  content_markdown: >
    **Cтатична** змінна - це ресурс пам'яті, створений під час компіляції, який існує від початку до кінця програми. Вони повинні мати явно вказані типи.
    

    A **статичний ресурс часу життя** - це ресурс пам'яті, який існує невизначено довго до кінця програми.  Зауважте, що за цим визначенням деякі ресурси зі статичним часом життя можуть бути створені під час виконання програми.


    Ресурси зі статичним часом життя мають спеціальний специфікатор часу життя `static`.


    `static` ресурси ніколи не **скидаються**.


    Якщо статичні ресурси містять посилання, то всі вони мають бути `static` (інакше вони не проживуть достатньо довго).


    Деталі про пам'ять:


    * Модифікація статичних змінних за своєю суттю є небезпечною, оскільки вони є глобально доступними для читання будь-ким, що призводить до можливості перегонів даних. Ми поговоримо про проблеми глобальних даних пізніше.

    * Rust дозволяє використовувати блоки `unsafe { ... }` для виконання операцій, для яких компілятор не може гарантувати безпеку пам'яті. [<span style="color:red; font-weight:bold;">R̸͉̟͈͔̄͛̾̇͜U̶͓͖͋̅Ṡ̴͉͇̃̉̀T̵̻̻͔̟͉́͆Ơ̷̥̟̳̓͝N̶̨̼̹̲͛Ö̵̝͉̖̏̾̔M̶̡̠̺̠̐͜Î̷̛͓̣̃̐̏C̸̥̤̭̏͛̎͜O̶̧͚͖͔̊͗̇͠N̸͇̰̏̏̽̃</span>](https://doc.rust-lang.org/nomicon/) не слід обговорювати легковажно.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=static%20PI%3A%20f64%20%3D%203.1415%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%BD%D1%96%20%D0%B7%D0%BC%D1%96%D0%BD%D0%BD%D1%96%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B6%20%D0%BC%D0%BE%D0%B6%D1%83%D1%82%D1%8C%20%D0%B1%D1%83%D1%82%D0%B8%20%D0%BE%D0%B1%D0%BC%D0%B5%D0%B6%D0%B5%D0%BD%D1%96%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%94%D1%8E%0A%20%20%20%20static%20mut%20SECRET%3A%20%26'static%20str%20%3D%20%22swordfish%22%3B%0A%0A%20%20%20%20%2F%2F%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D1%96%20%D0%BB%D1%96%D1%82%D0%B5%D1%80%D0%B0%D0%BB%D0%B8%20%D0%BC%D0%B0%D1%8E%D1%82%D1%8C%20'static%20%D1%87%D0%B0%D1%81%20%D0%B6%D0%B8%D1%82%D1%82%D1%8F%0A%20%20%20%20let%20msg%3A%20%26'static%20str%20%3D%20%22Hello%20World!%22%3B%0A%20%20%20%20let%20p%3A%20%26'static%20f64%20%3D%20%26PI%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20msg%2C%20p)%3B%0A%0A%20%20%20%20%2F%2F%20%D0%92%D0%B8%20%D0%BC%D0%BE%D0%B6%D0%B5%D1%82%D0%B5%20%D0%BF%D0%BE%D1%80%D1%83%D1%88%D1%83%D0%B2%D0%B0%D1%82%D0%B8%20%D0%B4%D0%B5%D1%8F%D0%BA%D1%96%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0%2C%20%D0%B0%D0%BB%D0%B5%20%D0%B2%D0%B8%20%D0%BF%D0%BE%D0%B2%D0%B8%D0%BD%D0%BD%D1%96%20%D0%B1%D1%83%D1%82%D0%B8%20%D1%8F%D0%B2%D0%BD%D0%B8%D0%BC%D0%B8%0A%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%2F%2F%20%D0%BC%D0%B8%20%D0%BC%D0%BE%D0%B6%D0%B5%D0%BC%D0%BE%20%D0%B2%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%B8%D1%82%D0%B8%20SECRET%20%D0%BD%D0%B0%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%BE%D0%B2%D0%B8%D0%B9%20%D0%BB%D1%96%D1%82%D0%B5%D1%80%D0%B0%D0%BB%2C%20%D0%BE%D1%81%D0%BA%D1%96%D0%BB%D1%8C%D0%BA%D0%B8%20%D0%B2%D1%96%D0%BD%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B6%20%D0%BC%D0%B0%D1%94%20%60static%0A%20%20%20%20%20%20%20%20SECRET%20%3D%20%22abracadabra%22%3B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%22%2C%20SECRET)%3B%0A%20%20%20%20%7D%0A%7D%0A
- title: Часи життя в типах даних
  content_markdown: >
    Подібно до функцій, типи даних можуть бути параметризовані специфікаторами часу життя їхніх членів.


    Rust перевіряє, що структура даних, яка містить посилання, ніколи не існує довше, ніж власники, на яких ці посилання вказують.


    Ми не можемо дозволити структурам бігати з посиланнями, що вказують на ніщо!
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=struct%20Foo%3C'a%3E%20%7B%0A%20%20%20%20i%3A%26'a%20i32%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2042%3B%0A%20%20%20%20let%20foo%20%3D%20Foo%20%7B%0A%20%20%20%20%20%20%20%20i%3A%20%26x%0A%20%20%20%20%7D%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cfoo.i)%3B%0A%7D%0A
- title: Розділ 5 - Висновки
  content_markdown: >
    Вітаємо, що ви пройшли це випробування! Я знаю, що багато чого треба засвоїти, але ви на правильному шляху до того, щоб стати Rustacean (Іржавцем). Сподіваємось, тепер зрозуміло, як Rust як мова має на меті вирішити багато з цих поширених проблем у системному програмуванні:


    * ненавмисна модифікація ресурсів

    * забути деконструювати ресурси

    * випадкова деконструкція ресурсів двічі

    * використання ресурсів після їх деконструкції

    * Перегони даних, спричинені записом до ресурсів, коли інші читають з ресурсів

    * чітке бачення ділянок коду, де компілятор не може надати гарантій


    У наступному розділі ми застосуємо деякі з цих знань, коли будемо розглядати, як Rust працює з текстом.
