- title: Розділ 6 - Текст
  content_markdown: >
    Тепер, коли ми трохи зрозуміли, як Rust працює з пам'яттю, ми готові поговорити про текст більш детально. Rust дуже піклується про міжнародні проблеми на рівні тексту і байтів, які можуть бути вам незнайомі з інших мов. Тим не менш, Rust має багато чудових інструментів для керування цими проблемами.
- title: Рядкові літерали
  content_markdown: >
    Рядкові літерали завжди мають кодування Unicode.


    Рядкові літерали мають тип `&'static str`:

    * `&` означає, що він посилається на місце у пам'яті, і не має `&mut`, що означає, що компілятор не дозволить його модифікацію

    * `'static` означає, що рядкові дані будуть доступні до кінця нашої програми (вони ніколи не знищуються)

    * `str` означає, що він вказує на послідовність байт, які завжди є коректними **utf-8**


    Деталі про пам'ять:

    * Компілятор Rust, скоріш за все, помістить ваш рядок у сегмент даних вашої програмної пам'яті

  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20%22привіт,%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20a.len())%3B%0A%7D%0A
- title: Що таке utf-8
  content_markdown: "Оскільки на комп'ютерах використовувалося все більше мов, світ потребував можливості представлення більшої кількості текстових символів,\nніж дозволяв ASCII (1 байт дозволяв закодувати лише 256 символів).\n\n**utf-8** було створено з варіативною довжиною байтів (від 1 до 4), що значно розширило набір можливих символів.\n\nПеревагою змінного розміру символів є те, що текст не містить зайвих байтів для дуже поширених символів ASCII (які в **utf-8** все ще займають лише 1 байт).\n\nНедоліком змінного розміру символів є те, що доступ до символів більше не можна здійснювати швидко\n(**O(1)**, тобто за сталий час) за допомогою простого індексування (наприклад, `my_text[3]` для отримання 4-го символу). Можливо, що\nпопередні символи мають різну ширину, змінюючи положення 4-го символу у послідовності байтів.\n\nЗамість цього нам доводиться ітеруватися через байтову послідовність **utf-8**, щоб зрозуміти, де саме починаються Unicode-символи (**O(n)**, тобто за лінійний час).\n\n**Ферріс**: «Я просто радий, що маю **UTF-8** для представлення емодзі моїх підводних друзів.»\n\n<span class=\"emoji\">\U0001F420\U0001F419\U0001F41F\U0001F42C\U0001F40B</span>\n"

- title: Екранування символів
  content_markdown: >
    Візуально представити певні символи складно, тому **екранні коди** дозволяють нам поставити символ на їхнє місце.


    Rust підтримує поширені коди екранування з мов, заснованих на C:

    * `\n` - новий рядок

    * `\r` - повернення каретки

    * `\t` - табуляція

    * `\\` - зворотна скісна риска

    * `\0` - нуль

    * `\'` - одинарні лапки


    Повний список можна знайти [тут](https://doc.rust-lang.org/reference/tokens.html).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26%27static%20str%20%3D%20%22Ферріс%20каже%3A%5Ct%5C%22привіт%5C%22%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Ca)%3B%0A%7D%0A
- title: Багаторядкові рядкові літерали
  content_markdown: |
    Рядки Rust за замовчуванням є багаторядковими.


    Використовуйте `\` у кінці рядка, якщо вам не потрібен перевід рядка.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20haiku%3A%20%26'static%20str%20%3D%20%22%0A%20%20%20%20%20%20%20%20Пишу%2C%20стираю%2C%20знов%20пишу%0A%20%20%20%20%20%20%20%20Знов%20стираю%2C%20і%20врешті-решт%0A%20%20%20%20%20%20%20%20Квітка%20маку.%0A%20%20%20%20%20%20%20%20-%20Татібана%20Хокусі%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20haiku)%3B%0A%20%20%20%20%0A%20%20%20%20println!(%22привіт,%20%5C%0A%20%20%20%20світ%22)%3B%20%2F%2F%20Простір%20перед%20%22словом%22%20світ%20ігнорується%0A%7D%0A
- title: Необроблені рядкові літерали
  content_markdown: >
    Необроблені рядки дозволяють записати послідовність символів дослівно, починаючи з `r#"` і закінчуючи `"#`. Це дозволяє вставляти символи, які у звичайному рядку можна сплутати з літералами (наприклад, подвійні лапки та зворотні скісні риски).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%3A%20%26'static%20str%20%3D%20r%23%22%0A%20%20%20%20%20%20%20%20%3Cdiv%20class%3D%22advice%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20Необроблені%20рядки%20корисні%20в%20деяких%20ситуаціях.%0A%20%20%20%20%20%20%20%20%3C%2Fdiv%3E%0A%20%20%20%20%20%20%20%20%22%23%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a)%3B%0A%7D%0A
- title: Рядкові літерали з файлів
  content_markdown: >
    Якщо у вас є дуже великий текст, спробуйте використати для нього макрос `include_str!`,
    щоб включити текст із локальних файлів у вашу програму:

    ```rust

    let hello_html = include_str!("hello.html");

    ```
- title: Рядкові зрізи
  content_markdown: >
    Зріз рядка - це посилання на послідовність байт у пам'яті, яка завжди має бути дійсною у кодуванні utf-8.


    Зріз рядка (підзріз) фрагмента `str` також має бути коректним у кодуванні utf-8.

    Загальні методи `&str`:

    * `len` повертає довжину рядкового літералу в байтах (не кількість символів).

    * `starts_with`/`ends_with` для базового тестування.

    * `is_empty` повертає true, якщо довжина нульова.

    * `find` повертає `Option<usize>` першої позиції деякого тексту.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20%22hi%20%F0%9F%A6%80%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20a.len())%3B%0A%20%20%20%20let%20first_word%20%3D%20%26a%5B0..2%5D%3B%0A%20%20%20%20let%20second_word%20%3D%20%26a%5B3..7%5D%3B%0A%20%20%20%20%2F%2F%20let%20half_crab%20%3D%20%26a%5B3..5%5D%3B%20НЕ%20ПРАЦЮЄ%0A%20%20%20%20%2F%2F%20Rust%20не%20дозволяє%20використовувати%20зрізи%20некоректних%20Unicode-символів%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20first_word%2C%20second_word)%3B%0A%7D%0A
- title: Chars
  content_markdown: >
    Зважаючи на великі труднощі у роботі з Unicode, Rust пропонує спосіб отримати послідовність байт utf-8 у вигляді вектора символів типу `char`.


    Довжина `char` завжди дорівнює 4 байтам (що дозволяє ефективно шукати окремі символи).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20збираємо%20символи%20у%20вектор%20типу%20char%0A%20%20%20%20let%20chars%20%3D%20%22hi%20%F0%9F%A6%80%22.chars().collect%3A%3A%3CVec%3Cchar%3E%3E()%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars.len())%3B%20%2F%2F%20має%20бути%204%0A%20%20%20%20%2F%2F%20оскільки%20символи%20займають%204%20байти%2C%20можемо%20конвертувати%20їх%20в%20u32%0A%20%20%20%20println!(%22%7B%7D%22%2C%20chars%5B3%5D%20as%20u32)%3B%0A%7D%0A
- title: String
  content_markdown: >
    **String** - це структура, яка володіє послідовністю utf-8 байт у пам'яті купи.


    Оскільки його пам'ять знаходиться на купі, його можна розширювати, модифікувати і т.д. так, як рядкові літерали не можуть.


    Загальні методи:


    * `push_str`, щоб додати додаткові utf-8 байти в кінець рядка.

    * `replace` для заміни послідовності байт utf-8 на інші.

    * `to_lowercase`/`to_uppercase` для зміни регістру.

    * `trim` для обрізки простору


    Коли String скидається, пам'ять купи для нього також скидається.


    У `String` є оператор `+`, який розширює рядок за допомогою `&str` і повертає сам себе, але він може бути не таким ергономічним, як ви сподіваєтесь.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20helloworld%20%3D%20String%3A%3Afrom(%22привіт,%22)%3B%0A%20%20%20%20helloworld.push_str(%22%20світ%22)%3B%0A%20%20%20%20helloworld%20%3D%20helloworld%20%2B%20%22!%22%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%7D%0A
- title: Текст, як параметр функції
  content_markdown: >
    Рядкові літерали та рядки зазвичай передаються функціям як фрагмент рядка. Це забезпечує велику гнучкість для більшості сценаріїв, де вам не потрібно передавати право власності.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20say_it_loud(msg%3A%26str)%7B%0A%20%20%20%20println!(%22%7B%7D!!!%22%2Cmsg.to_string().to_uppercase())%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20say_it_loud%20може%20позичати%20%26%27static%20str%20як%20%26str%0A%20%20%20%20say_it_loud(%22hello%22)%3B%0A%20%20%20%20%2F%2F%20say_it_loud%20також%20може%20позичати%20String%20як%20%26str%0A%20%20%20%20say_it_loud(%26String%3A%3Afrom(%22goodbye%22))%3B%0A%7D%0A
- title: Побудова рядків
  content_markdown: |
    `concat` і `join` - це два простих, але потужних способи побудови рядків.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20helloworld%20%3D%20%5B%22привіт,%22%2C%20%22%20%22%2C%20%22світ%22%2C%20%22!%22%5D.concat()%3B%0A%20%20%20%20let%20abc%20%3D%20%5B%22a%22%2C%20%22b%22%2C%20%22c%22%5D.join(%22%2C%22)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20helloworld)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cabc)%3B%0A%7D%0A
- title: Форматування рядків
  content_markdown: >
    Макрос `format!` дозволяє створити рядок, визначивши параметризований рядок із заповнювачами, які вказують, де і як слід розміщувати значення (наприклад, `{}`).


    `format!` використовує ті самі параметризовані рядки, що й `println!`.


    Можливості цієї функції занадто широкі для *Tour of Rust*; зверніться до документації [тут](https://doc.rust-lang.org/std/fmt/).
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20f%20%3D%20format!(%22таємниця%20життя%3A%20%7B%7D%22%2Ca)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2Cf)%3B%0A%7D%0A
- title: Конвертація рядків
  content_markdown: |
    Багато типів можна перетворити у рядок за допомогою функції `to_string`.


    Загальна функція `parse` може бути використана для перетворення рядків або рядкових літералів у типізоване значення. Ця функція повертає `Result`, тому що вона може завершитися невдачею.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20-%3E%20Result%3C()%2C%20std%3A%3Anum%3A%3AParseIntError%3E%20%7B%0A%20%20%20%20let%20a%20%3D%2042%3B%0A%20%20%20%20let%20a_string%20%3D%20a.to_string()%3B%0A%20%20%20%20let%20b%20%3D%20a_string.parse%3A%3A%3Ci32%3E()%3F%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%20%20%20%20Ok(())%0A%7D%0A
- title: Розділ 6 - Висновки
  content_markdown: >
    Тепер ви знаєте основи роботи з текстом!  Як ви бачили, Unicode робить роботу з текстом дещо складною, але стандартна бібліотека має багато функціональних можливостей, щоб полегшити роботу з ним.


    Досі ми розглядали Rust здебільшого через призму процедурної парадигми (тобто лише функції та дані), але настав час поговорити про особливості та можливості, які відкриває об'єктно-орієнтована парадигма Rust.
