- title: Розділ 1 - Основи
  content_markdown: >
    У цьому першому розділі ми розглянемо основи роботи з функціями, змінними та найпримітивнішими типами. Будемо раді бачити вас на борту!


    А ще, якщо вам цікаво, хто цей чарівний краб, який з вами розмовляє, то я - **Ферріс**, неофіційний маскот мови програмування Rust. Приємно познайомитись.


    Ознайомившись з Rust, ви можете назвати себе **Rustacean** (Іржавцем). Так називають себе люди, які використовують Rust, роблять внесок або цікавляться ним.
- title: The Rust Playground
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20println!(%22Ласкаво%20просимо%20на%20playground!%20Ви%20можете%20змінити%20код%20тут.%22)%3B%0A%7D%0A
  content_markdown: >
    У цьому турі використовується інтерактивний інструмент кодування від [Rust Playground] (https://play.rust-lang.org).


    Це чудовий спосіб експериментувати з Rust, демонструвати свою креативність та вирішувати завдання!

- title: Змінні
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20%2F%2F%20rust%20передбачає%20тип%20x%0A%20%20%20%20let%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20також%20може%20чітко%20вказувати%20на%20тип%0A%20%20%20%20let%20x%3A%20f64%20%3D%203.14159%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%0A%20%20%20%20%2F%2F%20rust%20також%20може%20оголошувати%20та%20ініціалізувати%20пізніше%2C%20але%20це%20робиться%20рідко%0A%20%20%20%20let%20x%3B%0A%20%20%20%20x%20%3D%200%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Змінні оголошуються з використанням ключового слова **let**.


    Під час присвоєння значення Rust зможе визначити тип вашої змінної у 99% випадків. Якщо не зможе, ви можете додати тип до оголошення змінної.


    Зверніть увагу, що ми можемо присвоювати одне й те саме ім'я змінній декілька разів. Це називається **затіненням змінної** (variable shadowing), і тип може бути змінено при наступних звертаннях до цього імені.


    Імена змінних завжди у регістрі `snake_case`.

- title: Зміна змінних
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20mut%20x%20%3D%2042%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%20%20%20%20x%20%3D%2013%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20x)%3B%0A%7D%0A
  content_markdown: >
    Rust дуже переймається тим, які змінні можна змінювати. Значення поділяються на два типи:


    * **mutable** (змінний) - компілятор дозволить записувати та зчитувати змінну.

    * **immutable** (незмінний) - компілятор дозволить лише читати зі змінної.


    Значення, що змінюються, позначаються ключовим словом **mut**.


    Пізніше ми розповімо більше про цю концепцію, а поки що просто слідкуйте за цим ключовим словом.

- title: Базові типи
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20x%20%3D%2012%3B%20%2F%2F%20за%20замовчуванням%20це%20i32%0A%20%20%20%20let%20a%20%3D%2012u8%3B%0A%20%20%20%20let%20b%20%3D%204.3%3B%20%2F%2F%20за%20замовчуванням%20це%20f64%0A%20%20%20%20let%20c%20%3D%204.3f32%3B%0A%20%20%20%20let%20bv%20%3D%20true%3B%0A%20%20%20%20let%20t%20%3D%20(13%2C%20false)%3B%0A%20%20%20%20let%20sentence%20%3D%20%22привіт,%20світ!%22%3B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%20%7B%7D%22%2C%0A%20%20%20%20%20%20%20%20x%2C%20a%2C%20b%2C%20c%2C%20bv%2C%20t.0%2C%20t.1%2C%20sentence%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Rust має різні знайомі нам типи:


    * булеві значення - `bool` для представлення істина/хиба

    * цілі числа без знака - `u8` `u16` `u32` `u64` `u128` для представлення додатних цілих чисел

    * цілі числа зі знаком - `i8` `i16` `i32` `i64` `i128` для представлення цілих чисел

    * цілі числа розміру вказівника  - `usize` `isize` для представлення індексів та розмірів об'єктів у пам'яті

    * числа з плаваючою точкою - `f32` `f64`

    * символи - `char` для представлення одного символу Unicode

    * кортежі - `(значення, значення, ...)` для передачі фіксованих послідовностей значень у стеку

    * масиви - `[значення, значення, ...]` колекція схожих елементів із фіксованою довжиною, відомою під час компіляції

    * зрізи - колекція схожих елементів із довжиною, відомою під час виконання.

    * `str`(зріз рядка) - текст із довжиною, відомою під час виконання.


    Текст у Rust може бути складнішим, ніж ви звикли в інших мовах. Оскільки Rust є системною мовою програмування, він приділяє увагу питанням пам’яті, які можуть бути для вас новими. Ми детально розглянемо це пізніше.


    Числові типи можна явно вказати, додаючи тип до кінця числа (наприклад, `13u32`, `2u8`).

- title: Перетворення базових типів
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%2013u8%3B%0A%20%20%20%20let%20b%20%3D%207u32%3B%0A%20%20%20%20let%20c%20%3D%20a%20as%20u32%20%2B%20b%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20c)%3B%0A%0A%20%20%20%20let%20t%20%3D%20true%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20t%20as%20u8)%3B%0A%7D%0A
  content_markdown: >
    Rust вимагає чіткості, коли мова йде про числові типи. Ви не можете випадково використати `u8` замість `u32` без помилки.


    На щастя, Rust робить перетворення числових типів дуже простим за допомогою ключового слова **as**.

- title: Константи
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=const%20PI%3A%20f32%20%3D%203.14159%3B%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%0A%20%20%20%20%20%20%20%20%22Щоб%20створити%20яблучний%20%7B%7D%20з%20нуля%2C%20ви%20повинні%20спочатку%20створити%20всесвіт.%22%2C%0A%20%20%20%20%20%20%20%20PI%0A%20%20%20%20)%3B%0A%7D%0A
  content_markdown: >
    Константи дозволяють нам ефективно визначати загальне значення, яке використовується в нашому коді багато разів. Замість того, щоб копіювати значення як змінні там, де вони використовуються, константи безпосередньо замінюють текстовий ідентифікатор, де вони використовуються, своїм значенням під час компіляції.


    На відміну від змінних, тип констант завжди має бути вказаний явно.


    Константні імена завжди знаходяться у регістрі `SCREAMING_SNAKE_CASE`.

- title: Масиви
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20main()%20%7B%0A%20%20%20%20let%20nums%3A%20%5Bi32%3B%203%5D%20%3D%20%5B1%2C%202%2C%203%5D%3B%0A%20%20%20%20println!(%22%7B%3A%3F%7D%22%2C%20nums)%3B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20nums%5B1%5D)%3B%0A%7D%0A
  content_markdown: >
    *Масив* - це **набір елементів даних фіксованої довжини**, які мають однаковий тип.


    Тип даних для *масиву* має вигляд `[T;N]`, де T - тип елементів, а N - фіксована довжина, відома під час компіляції.


    Окремі елементи можна отримати за допомогою оператора `[x]`, де *x* - це індекс *usize* (починаючи з 0) потрібного вам елемента.


    Колекції з динамічною довжиною, які часто називають динамічними або змінними масивами, описано у наступному розділі про **Вектори**.
- title: Функції
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20add(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20i32%20%7B%0A%20%20%20%20return%20x%20%2B%20y%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20println!(%22%7B%7D%22%2C%20add(42%2C%2013))%3B%0A%7D%0A
  content_markdown: >
    Функція має нуль або більше параметрів.


    У цьому прикладі функція *add* отримує два аргументи типу `i32` (знакове ціле число довжиною 32 біти).


    Якщо ви просто хочете повернути вираз, ви можете опустити ключове слово `return` і крапку з комою в кінці, як ми зробили у функції *subtract*.


    Імена функцій завжди в регістрі `snake_case`.


    Підказка: якщо ви визначаєте функцію, дані, які вона приймає, називаються параметрами. Якщо ви викликаєте цю функцію і передаєте їй дані, то вони називаються аргументами.
- title: Кілька значень, що повертаються
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20swap(x%3A%20i32%2C%20y%3A%20i32)%20-%3E%20(i32%2C%20i32)%20%7B%0A%20%20%20%20return%20(y%2C%20x)%3B%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20%2F%2F%20повертає%20кортеж%20значень,%20що%20повертаються%0A%20%20%20%20let%20result%20%3D%20swap(123%2C%20321)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20result.0%2C%20result.1)%3B%0A%0A%20%20%20%20%2F%2F%20деструктурувати%20кортеж%20на%20дві%20змінні%20по%20іменам%0A%20%20%20%20let%20(a%2C%20b)%20%3D%20swap(result.0%2C%20result.1)%3B%0A%20%20%20%20println!(%22%7B%7D%20%7B%7D%22%2C%20a%2C%20b)%3B%0A%7D%0A
  content_markdown: >
    Функції можуть повертати декілька значень, повертаючи **кортеж** значень.


    На елементи кортежу можна посилатися за їхнім індексним номером.


    Rust підтримує різні види деструктуризації, які ми побачимо в різних формах, дозволяючи нам витягувати підчастини структур даних ергономічними способами. Слідкуйте за цим!

- title: Повернення нічого
  content_markdown: >
    Якщо для функції не вказано тип повернення, вона повертає порожній кортеж, також відомий як *unit* (одиниця).


    Порожній кортеж позначається як `()`.


    Використання `()` це незвично, але буде зустрічатися досить часто, тому корисно знати, що відбувається.
  code: >-
    https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=fn%20make_nothing()%20-%3E%20()%20%7B%0A%20%20%20%20return%20()%3B%0A%7D%0A%0A%2F%2F%20тип%20повернення%20мається%20на%20увазі%20як%20()%0Afn%20make_nothing2()%20%7B%0A%20%20%20%20%2F%2F%20ця%20функція%20поверне%20(),%20якщо%20нічого%20не%20вказано%20для%20повернення%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20a%20%3D%20make_nothing()%3B%0A%20%20%20%20let%20b%20%3D%20make_nothing2()%3B%0A%0A%20%20%20%20%2F%2F%20Виведення%20відладочного%20рядка%20для%20a%20та%20b%0A%20%20%20%20%2F%2F%20Тому%20що%20важко%20виводити%20ніщо%0A%20%20%20%20println!(%22Значення%20a%3A%20%7B%3A%3F%7D%22%2C%20a)%3B%0A%20%20%20%20println!(%22Значення%20b%3A%20%7B%3A%3F%7D%22%2C%20b)%3B%0A%7D%0A

- title: Розділ 1 - Висновки
  content_markdown: >
    Поки що непогано виходить! Основи Rust не такі вже й погані, чи не так? Ми зазирнули в те, як мислить компілятор Rust. Як мову системного програмування, він дуже турбується про розмір значень у пам'яті, про те, чи можна їх змінювати, і про те, щоб ваша математика була саме такою, якою ви хочете її бачити. Далі ми розглянемо деяких старих друзів: тести `if` та цикли `for`.


    Більше ресурсів:


    * [Youtube: Rust Cast - A deeper dive on Rust's primitive number
    types](https://www.youtube.com/watch?v=n5TRBkbystY)

    * [Website: Rust Book 2018 - A deeper description on basic data
    types](https://doc.rust-lang.org/1.30.0/book/2018-edition/ch03-02-data-types.html)

    * [Website: Rust Cheat Sheet - Data Types](https://cheats.rs/#basic-types)
